<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>cpp-primer - FC</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 5.0.0"></head>


<body>
  <header style="height: 40vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
                cpp-primer
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2021-04-08 10:36">
      2021年4月8日 上午
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      5.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      64
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <h2 id="第一章-开始"><a href="#第一章-开始" class="headerlink" title="第一章 开始"></a>第一章 开始</h2><h3 id="1-1-编写一个简单的C-程序"><a href="#1-1-编写一个简单的C-程序" class="headerlink" title="1.1 编写一个简单的C++程序"></a>1.1 编写一个简单的C++程序</h3><p> 每个C++程序都包含一个或多个函数，其中一个必须命名为main. </p>
<h3 id="1-2-初识输入输出"><a href="#1-2-初识输入输出" class="headerlink" title="1.2 初识输入输出"></a>1.2 初识输入输出</h3><table>
<thead>
<tr>
<th><strong>对象</strong></th>
<th><strong>用途</strong></th>
</tr>
</thead>
<tbody><tr>
<td>cin</td>
<td>标准输入</td>
</tr>
<tr>
<td>cout</td>
<td>标准输出</td>
</tr>
<tr>
<td>cerr</td>
<td>标准错误</td>
</tr>
<tr>
<td>clog</td>
<td>输出运行时的一般性消息</td>
</tr>
</tbody></table>
<h3 id="1-3-注释简介"><a href="#1-3-注释简介" class="headerlink" title="1.3 注释简介"></a>1.3 注释简介</h3><p>两种：</p>
<p>单行注释：//</p>
<p>界定符：/* 和 */</p>
<h3 id="1-4-控制流"><a href="#1-4-控制流" class="headerlink" title="1.4 控制流"></a>1.4 控制流</h3><p>while;for;if;</p>
<h2 id="第二章-变量和基本类型"><a href="#第二章-变量和基本类型" class="headerlink" title="第二章 变量和基本类型"></a>第二章 变量和基本类型</h2><p> 不要混用符号类型和无符号类型。 </p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">位</th>
<th align="left">范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">char</td>
<td align="center">1 个字节</td>
<td align="left">-128 到 127 或者 0 到 255</td>
</tr>
<tr>
<td align="center">unsigned char</td>
<td align="center">1 个字节</td>
<td align="left">0 到 255</td>
</tr>
<tr>
<td align="center">signed char</td>
<td align="center">1 个字节</td>
<td align="left">-128 到 127</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">4 个字节</td>
<td align="left">-2147483648 到 2147483647</td>
</tr>
<tr>
<td align="center">unsigned int</td>
<td align="center">4 个字节</td>
<td align="left">0 到 4294967295</td>
</tr>
<tr>
<td align="center">signed int</td>
<td align="center">4 个字节</td>
<td align="left">-2147483648 到 2147483647</td>
</tr>
<tr>
<td align="center">short int</td>
<td align="center">2 个字节</td>
<td align="left">-32768 到 32767</td>
</tr>
<tr>
<td align="center">unsigned short int</td>
<td align="center">2 个字节</td>
<td align="left">0 到 65,535</td>
</tr>
<tr>
<td align="center">signed short int</td>
<td align="center">2 个字节</td>
<td align="left">-32768 到 32767</td>
</tr>
<tr>
<td align="center">long int</td>
<td align="center">8 个字节</td>
<td align="left">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td>
</tr>
<tr>
<td align="center">signed long int</td>
<td align="center">8 个字节</td>
<td align="left">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td>
</tr>
<tr>
<td align="center">unsigned long int</td>
<td align="center">8 个字节</td>
<td align="left">0 到 18,446,744,073,709,551,615</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">4 个字节</td>
<td align="left">精度型占4个字节（32位）内存空间，+/- 3.4e +/- 38 (~7 个数字)</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">8 个字节</td>
<td align="left">双精度型占8 个字节（64位）内存空间，+/- 1.7e +/- 308 (~15 个数字)</td>
</tr>
<tr>
<td align="center">long double</td>
<td align="center">16 个字节</td>
<td align="left">长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。</td>
</tr>
<tr>
<td align="center">wchar_t</td>
<td align="center">2 或 4 个字节</td>
<td align="left">1 个宽字符</td>
</tr>
</tbody></table>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><h4 id="基本形式："><a href="#基本形式：" class="headerlink" title="基本形式："></a>基本形式：</h4><p>类型说明符，随后紧跟着一个或者多个变量名组成的列表，其中变量名以逗号分隔，最后以分号结束。</p>
<h4 id="初始值"><a href="#初始值" class="headerlink" title="初始值"></a>初始值</h4><p>初始化和赋值是2个完全不同的操作。初始化的含义是创建变量的时候赋予一个初始值，而赋值的含义是把对象的当前值擦除，用一个新值来替代。两者区别很小。</p>
<h4 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h4><p>用花括号来初始化变量的方式，称为列表初始化。</p>
<h4 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a>默认初始化</h4><p>如果定义变量没有指定初始值，则变量被默认初始化。</p>
<p>:::tips<br>例外情况：<br>定义在函数体内部的内置类型变量将不被初始化，其值未定义。<br>建议初始化每个内置类型的变量。<br>:::</p>
<h3 id="变量声明和定义的关系"><a href="#变量声明和定义的关系" class="headerlink" title="变量声明和定义的关系"></a>变量声明和定义的关系</h3><h4 id="变量声明："><a href="#变量声明：" class="headerlink" title="变量声明："></a>变量声明：</h4><p>​    规定了变量的类型和名字。</p>
<h4 id="变量定义："><a href="#变量定义：" class="headerlink" title="变量定义："></a>变量定义：</h4><p>​    除声明之外，还需要申请存储空间。</p>
<p> 如果想声明一个变量，而非定义它，需要使用extern关键词。 </p>
<pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> i;   <span class="hljs-comment">// 声明i而非定义i</span>
<span class="hljs-keyword">int</span> j;      <span class="hljs-comment">// 声明并定义j </span></code></pre>

<p> ::: tip变量只能被定义一次，但可以被多次声明。::: </p>
<h4 id="名字的作用域"><a href="#名字的作用域" class="headerlink" title="名字的作用域"></a>名字的作用域</h4><p>作用域：C++中大多数作用域都用花括号分隔。</p>
<p>作用域中一旦声明了某个名字，它所嵌套的所有作用域都能访问该名字。同时，<strong>允许在内层作用域中重新定义外层作用域中有的名字。</strong></p>
<p>::: warning如果函数有可能用到某全局变量，则不宜再定义一个同名的局部变量。:::</p>
<h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><p> 定义:复合类型是基于其他类型定义的类型。 </p>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>引用：为对象起另外一个名字。 </p>
<p> ::: warning引用必须被初始化。引用本身不是对象，所以不能定义引用的引用。引用要和绑定的对象严格匹配。引用类型的初始值，必须是一个对象。::: </p>
<h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><p>指针：本身就是一个对象。允许对指针赋值和拷贝。指针无须在定义的时候赋值。</p>
<p>（1）利用指针访问对象</p>
<p>如果指针指向了一个对象，则允许使用解引用符（*）来访问该对象。</p>
<p>（2）void* 指针</p>
<p> The void pointer in C is a pointer which is not associated with any data types. It points to some dat location in the storage means points to the address of variables. It is also called general purpose pointer. In C, malloc() and calloc() functions return void * or generic pointers. </p>
<pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
   <span class="hljs-keyword">int</span> a = <span class="hljs-number">7</span>;
   <span class="hljs-keyword">float</span> b = <span class="hljs-number">7.6</span>;
   <span class="hljs-keyword">void</span> *p;
   p = &amp;a;
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Integer variable is = %d&quot;</span>, *( (<span class="hljs-keyword">int</span>*) p) );
   p = &amp;b;
   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nFloat variable is = %f&quot;</span>, *( (<span class="hljs-keyword">float</span>*) p) );
   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>

<h4 id="理解符合类型的声明"><a href="#理解符合类型的声明" class="headerlink" title="理解符合类型的声明"></a>理解符合类型的声明</h4><h5 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h5><p>** 表示指向指针的指针</p>
<p>*** 表示指向指针的指针的指针</p>
<h4 id="指向指针的引用"><a href="#指向指针的引用" class="headerlink" title="指向指针的引用"></a>指向指针的引用</h4><p>不能定义指向引用的指针。但指针是对象，所以存在对指针的引用。</p>
<h3 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h3><p> 定义：const用于定义一个变量，它的值不能被改变。const对象必须初始化。 </p>
<p>::: tip </p>
<p>    编译器将在编译过程中把用 到该变量的地方都替换成对应的值，如果程序包含多个文件，则每个用了const 对象的文件都应可以访问到他的初始值。为了支持这个用法， 同时避免对同一变量的重复定义，默认情况下，const对象仅设定为仅在文件内有效。<br>    为了让const对象在多个文件均可共享，解决办法是，对于const 变量不管是声明还是定义都添加extern关键字。</p>
<p>:::</p>
<h4 id="const的引用"><a href="#const的引用" class="headerlink" title="const的引用"></a>const的引用</h4><p>允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式。一般，引用的类型必须与其所引用对象的类型一致，特殊情况是表达式。</p>
<h4 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h4><p> 弄清楚类型，可以从右边往左边阅读。 </p>
<ul>
<li>const 修饰指针指向的内容，则内容为不可变量。 </li>
</ul>
<pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *p = <span class="hljs-number">8</span>;</code></pre>
<p>则指针指向的内容数值 <code>8</code> 不可改变。简称左定值，因为 const 位于 * 号的左边。</p>
<ul>
<li>const 修饰指针，则指针为不可变量。 </li>
</ul>
<pre><code class="hljs cpp"><span class="hljs-keyword">int</span> a = <span class="hljs-number">8</span>;
<span class="hljs-keyword">int</span>* <span class="hljs-keyword">const</span> p = &amp;a;
*p = <span class="hljs-number">9</span>; <span class="hljs-comment">// 正确</span>
<span class="hljs-keyword">int</span>  b = <span class="hljs-number">7</span>;
p = &amp;b; <span class="hljs-comment">// 错误</span></code></pre>

<ul>
<li>const 修饰指针和指针指向的内容，则指针和指针指向的内容都为不可变量。 </li>
</ul>
<pre><code class="hljs cpp"><span class="hljs-keyword">int</span> a = <span class="hljs-number">8</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> * <span class="hljs-keyword">const</span>  p = &amp;a;</code></pre>

<p>这种情况是上两种情况的结合， 即指针与指向的内容和指针指向的内存地址都不可变</p>
<p> <strong>“左定值，右定向，const修饰不变量”</strong> </p>
<h4 id="常量函数"><a href="#常量函数" class="headerlink" title="常量函数"></a>常量函数</h4><p> &lt;类型说明符&gt;&lt;函数名&gt;(&lt;参数表&gt;)const; </p>
<p>要注意的是，修饰符const要加在函数说明的尾部（若放在首部的话，则是对函数返回值的修饰,即返回值是const），它是函数类型的一部分。</p>
<pre><code class="hljs cpp"><span class="hljs-keyword">int</span> me;
<span class="hljs-keyword">int</span> readme <span class="hljs-keyword">const</span> &#123; <span class="hljs-comment">// 常量函数 </span>
    <span class="hljs-keyword">return</span> me;
&#125;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">writeme</span><span class="hljs-params">()</span> </span>&#123; 
    me = <span class="hljs-number">1</span>; 
&#125; </code></pre>
<p>当一个函数被const说明后，其函数中出现的对外部数据的<strong>任何写入或修改都将被系统检查为出错</strong>。如果把函数writeme()说明为：</p>
<pre><code class="hljs cpp\">void writeme() const &#123;
    me &#x3D; 1; 
&#125;   </code></pre>

<h4 id="const修饰类成员函数"><a href="#const修饰类成员函数" class="headerlink" title="const修饰类成员函数"></a>const修饰类成员函数</h4><p> const 修饰类成员函数，其目的是防止成员函数修改被调用对象的值，如果我们不想修改一个调用对象的值，所有的成员函数都应当声明为 const 成员函数。 </p>
<p> <strong>注意：</strong>const 关键字不能与 static 关键字同时使用，因为 static 关键字修饰静态成员函数，静态成员函数不含有 this 指针，即不能实例化，const 成员函数必须具体到某一实例。 </p>
<p>  值得注意的是，把一个成员函数声明为const可以保证这个成员函数不修改数据成员，但是，如果据成员是指针，则const成员函数并不能保证不修改指针指向的对象，编译器不会把这种修改检测为错误。例如， </p>
<pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Name</span> &#123;</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s)</span> <span class="hljs-keyword">const</span></span>;
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">char</span> *m_sName;
&#125;;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s)</span> <span class="hljs-keyword">const</span> </span>&#123;
    m_sName = s.c_str();      <span class="hljs-comment">// 错误！不能修改m_sName;</span>

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.size(); ++i) 
        m_sName[i] = s[i];    <span class="hljs-comment">// 不好的风格，但不是错误的</span>
&#125;</code></pre>

<p>const成员函数可以被具有相同参数列表的非const成员函数重载，例如，</p>
<pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Screen</span> &#123;</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> <span class="hljs-keyword">const</span></span>;
&#125;;</code></pre>

<p>​    在这种情况下，类对象的常量性决定调用哪个函数。 </p>
<pre><code class="hljs cpp"><span class="hljs-keyword">const</span> Screen cs;
Screen cc2;
<span class="hljs-keyword">char</span> ch = cs.get(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 调用const成员函数</span>
ch = cs2.get(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);     <span class="hljs-comment">// 调用非const成员函数</span></code></pre>



<h4 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h4><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/14116003/difference-between-constexpr-and-const">https://stackoverflow.com/questions/14116003/difference-between-constexpr-and-const</a></p>
<h3 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h3><h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><p> 两种方法用于定义类型别名： </p>
<p> （1）使用关键词typedef </p>
<pre><code class="hljs angelscript"><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">double</span> wages; <span class="hljs-comment">//wages是double的同义词</span>
<span class="hljs-keyword">typedef</span> wages *p; <span class="hljs-comment">// p是double*的同义词</span></code></pre>

<p> （2）别名声明 </p>
<pre><code class="hljs c++"><span class="hljs-keyword">using</span> SI = Sales_item;  <span class="hljs-comment">// SI是Sales_item的同义词</span></code></pre>

<p>auto类型说明符：让编译器通过初始值来推算变量的类型。</p>
<p>decltype类型指示符：选择并返回操作符的数据类型。只得到类型，不实际计算表达式的值。</p>
<pre><code class="hljs c++"><span class="hljs-keyword">int</span> i = <span class="hljs-number">4</span>;
<span class="hljs-keyword">decltype</span>(i) a; <span class="hljs-comment">//推导结果为int。a的类型为int。</span></code></pre>

<h3 id="自定义数据结构"><a href="#自定义数据结构" class="headerlink" title="自定义数据结构"></a>自定义数据结构</h3><p>（1）类</p>
<p>数据结构是把一组相关的数据元素组织起来，然后使用它们的策略和方法。</p>
<p>类一般不定义在函数体内，为了确保各个文件中类的定义一致，类通常被定义在头文件中，而且类所在头文件的名字应该与类的名字一样。</p>
<p>头文件通常包含那些被定义一次的实体。</p>
<p>（2）预处理器</p>
<pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> SALES_DATA_H</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SALES_DATA_H</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre>

<p>一般把预处理变量的名字全部大写。</p>
<h2 id="字符串、向量和数组"><a href="#字符串、向量和数组" class="headerlink" title="字符串、向量和数组"></a><strong>字符串、向量和数组</strong></h2><p> string表示可变长的字符序列，vector存放的是某种给定类型对象的可变长序列。 </p>
<h3 id="命名空间的-using-声明"><a href="#命名空间的-using-声明" class="headerlink" title="命名空间的 using 声明"></a>命名空间的 using 声明</h3><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>:name; </code></pre>

<p> <strong>头文件不应包含using声明。</strong> </p>
<h3 id="标准库类型-string"><a href="#标准库类型-string" class="headerlink" title="标准库类型 string"></a>标准库类型 string</h3><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</code></pre>

<h4 id="定义和初始化"><a href="#定义和初始化" class="headerlink" title="定义和初始化"></a>定义和初始化</h4><pre><code class="hljs cpp"><span class="hljs-built_in">string</span> s1;
<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s2</span><span class="hljs-params">(s1)</span></span>;
<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s3</span><span class="hljs-params">(<span class="hljs-string">&quot;value&quot;</span>)</span></span>;
s3 = <span class="hljs-string">&quot;value&quot;</span>;
<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s4</span><span class="hljs-params">(n, <span class="hljs-string">&#x27;c&#x27;</span>)</span></span>;  <span class="hljs-comment">// n个c</span></code></pre>

<h4 id="string对象的操作"><a href="#string对象的操作" class="headerlink" title="string对象的操作"></a>string对象的操作</h4><pre><code class="hljs cpp">s.empty();      <span class="hljs-comment">// 判空</span>
s.size();       <span class="hljs-comment">// 字符个数</span>
s[n];           <span class="hljs-comment">// s中第n个字符的引用</span>
s1+s2;          <span class="hljs-comment">// s1和s2连接</span>
&lt;,&lt;=,&gt;,&gt;=       <span class="hljs-comment">// 比较</span></code></pre>

<h4 id="处理string对象中的字符-遍历给定序列中的每个值执行某种操作"><a href="#处理string对象中的字符-遍历给定序列中的每个值执行某种操作" class="headerlink" title="处理string对象中的字符 遍历给定序列中的每个值执行某种操作"></a>处理string对象中的字符 遍历给定序列中的每个值执行某种操作</h4><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (declaration : expression)   
        statement</code></pre>

<h3 id="标准库类型-vector"><a href="#标准库类型-vector" class="headerlink" title="标准库类型 vector"></a>标准库类型 vector</h3><p>标准库vector表示对象的集合，其中所有对象的类型都相同。</p>
<p>vector是一个类模板，而不是类型。</p>
<h4 id="定义和初始化vector对象"><a href="#定义和初始化vector对象" class="headerlink" title="定义和初始化vector对象"></a>定义和初始化vector对象</h4><pre><code class="hljs cpp"><span class="hljs-built_in">vector</span>&lt;T&gt; v1;
<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;T&gt; <span class="hljs-title">v2</span><span class="hljs-params">(v1)</span></span>;
<span class="hljs-built_in">vector</span>&lt;T&gt; v2 = v1;
<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;T&gt; <span class="hljs-title">v3</span><span class="hljs-params">(n, val)</span></span>;
<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;T&gt; <span class="hljs-title">v4</span><span class="hljs-params">(n)</span></span>;
<span class="hljs-built_in">vector</span>&lt;T&gt; v5&#123;a,b,c...&#125;
vecrot&lt;T&gt; v5=&#123;a,b,c...&#125; </code></pre>

<p> 如果用圆括号，那么提供的值是用来构造vector对象的。 </p>
<p> 如果用花括号，则是使用列表初始化该vector对象。 </p>
<h4 id="向vector对象添加元素"><a href="#向vector对象添加元素" class="headerlink" title="向vector对象添加元素"></a>向vector对象添加元素</h4><p> 先定义一个空的vector对象，在运行的时候使用**push_back()**向其中添加。 </p>
<h4 id="其他vector操作"><a href="#其他vector操作" class="headerlink" title="其他vector操作"></a>其他vector操作</h4><pre><code class="hljs c++">v.empty();
v.<span class="hljs-built_in">size</span>();
v.push_back(t);
v[n];</code></pre>

<h3 id="迭代器介绍"><a href="#迭代器介绍" class="headerlink" title="迭代器介绍"></a>迭代器介绍</h3><h4 id="迭代器运算符"><a href="#迭代器运算符" class="headerlink" title="迭代器运算符"></a>迭代器运算符</h4><pre><code class="hljs cpp">*iter            <span class="hljs-comment">// 解引用，返回引用</span>
iter-&gt;mem        <span class="hljs-comment">// 等价于  (*iter).mem</span>
++iter
--iter
iter1 == iter2
iter1 != iter2
iter + n
iter - n
iter += n
iter -= n
iter1 - iter2     <span class="hljs-comment">// 两个迭代器相减的结果是它们之间的距离</span>
&gt;, &gt;=, &lt;, &lt;=      <span class="hljs-comment">// 位置比较</span></code></pre>

<p>::: warning</p>
<p>凡是使用了迭代器的循环体，都不能向迭代器所属的容器添加元素。</p>
<p>:::</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p> 数组、指针 </p>
<p> 使用数组下标的时候，通常将其定义为size_t类型。 </p>
<p>不存在引用的数组。</p>
<p>如果两个指针分别指向不相关的对象，则不能进行对这2个指针进行比较。</p>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p><strong>begin</strong> string和vector的成员，返回指向第一个元素的迭代器。也是一个标准库函数，输入一个数组，返回指向该数组首元素的指针。</p>
<p><strong>end</strong> string和vector的成员，返回一个尾后迭代器。也是一个标准库函数，输入一个数组，返回指向该数组尾元素的下一个位置的指针。</p>
<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p><strong>重载运算符</strong>：为已经存在的运算符赋予了另外一层含义。</p>
<p><strong>右值：</strong> 当一个对象用作右值得时候，用的是对象的<strong>值</strong>（内容）。</p>
<p><strong>左值：</strong> 当对象被用作左值得时候，用的是对象的<strong>身份</strong>（在内存中的位置）。</p>
<p><strong>左值 (lvalue, locator value)</strong> 表示了一个占据内存中某个可识别的位置（也就是一个地址）的对象。</p>
<p><strong>右值 (rvalue)</strong> 则使用排除法来定义。一个表达式不是 <em>左值</em> 就是 <em>右值</em> 。 那么，右值是一个 <em>不</em> 表示内存中某个可识别位置的对象的表达式。</p>
<p><a target="_blank" rel="noopener" href="https://nettee.github.io/posts/2018/Understanding-lvalues-and-rvalues-in-C-and-C/">https://nettee.github.io/posts/2018/Understanding-lvalues-and-rvalues-in-C-and-C/</a></p>
<h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p> %： 参与取余运算的运算对象必须是<strong>整数</strong>类型。 </p>
<h3 id="逻辑和关系运算符"><a href="#逻辑和关系运算符" class="headerlink" title="逻辑和关系运算符"></a>逻辑和关系运算符</h3><table>
<thead>
<tr>
<th align="center">运算符</th>
</tr>
</thead>
<tbody><tr>
<td align="center">!</td>
</tr>
<tr>
<td align="center">&lt;</td>
</tr>
<tr>
<td align="center">&lt;=</td>
</tr>
<tr>
<td align="center">&gt;</td>
</tr>
<tr>
<td align="center">&gt;=</td>
</tr>
<tr>
<td align="center">==</td>
</tr>
<tr>
<td align="center">!=</td>
</tr>
<tr>
<td align="center">&amp;&amp;</td>
</tr>
<tr>
<td align="center">||</td>
</tr>
</tbody></table>
<p> &amp;&amp; 运算符和 || 运算符都是先求左侧运算对象的值再求右侧运算对象的值。 </p>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>赋值运算符满足右结合律。</p>
<p>不要混淆相等运算符和赋值运算符</p>
<h3 id="递增和递减运算符"><a href="#递增和递减运算符" class="headerlink" title="递增和递减运算符"></a>递增和递减运算符</h3><p>递增运算符 ++</p>
<p>递减运算符 –</p>
<h3 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h3><p> 点运算符和箭头运算符 </p>
<pre><code class="hljs c++">n = (*p).<span class="hljs-built_in">size</span>();
n = p-&gt;<span class="hljs-built_in">size</span>(); </code></pre>

<h3 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h3><pre><code class="hljs cpp">condition ? expression1 : expression2; </code></pre>

<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9UZFZFlIibIBPK52gb5KatGRPVOxJAJkwamf6aT5Qlb7icLmA1kzjEvqxl9ibIwWeLlT2OcuhkLaM1Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="/img/loading.gif" alt="图片"></p>
<h3 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h3><p> sizeof运算符返回一条表达式或一个类型名字所占的字节数，其所得值是一个size_t类型，是一个常量表达式。 </p>
<pre><code class="hljs c++"><span class="hljs-keyword">sizeof</span> (type)
<span class="hljs-keyword">sizeof</span> expr</code></pre>

<h3 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h3><p> 逗号运算符含有两个运算对象，按照从左向右的顺序依次求值。 </p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><h4 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h4><h4 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h4><p>C++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast</p>
<h4 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h4><p>用于将const变量转为非const</p>
<pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> constant = <span class="hljs-number">21</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>* const_p = &amp;constant;
<span class="hljs-keyword">int</span>* modifier = <span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-keyword">int</span>*&gt;(const_p);
*modifier = <span class="hljs-number">7</span>;
<span class="hljs-built_in">cout</span> &lt;&lt; constant &lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;  *modifier &lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt; <span class="hljs-built_in">endl</span>;
<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;constant: &quot;</span> &lt;&lt; constant &lt;&lt; <span class="hljs-built_in">endl</span>;
<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;const_p: &quot;</span> &lt;&lt; *const_p &lt;&lt; <span class="hljs-built_in">endl</span>;
<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;modifier: &quot;</span> &lt;&lt; *modifier &lt;&lt; <span class="hljs-built_in">endl</span>;
<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;constant: &quot;</span> &lt;&lt; &amp;constant &lt;&lt; <span class="hljs-built_in">endl</span>;
<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;const_p: &quot;</span> &lt;&lt; const_p &lt;&lt; <span class="hljs-built_in">endl</span>;
<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;modifier: &quot;</span> &lt;&lt; modifier &lt;&lt; <span class="hljs-built_in">endl</span>;
<span class="hljs-comment">/**</span>
<span class="hljs-comment">注意constant的值还是21， *modifier值变成了7</span>
<span class="hljs-comment">并且&amp;constant、const_p、modifier指向的地址相同</span>
<span class="hljs-comment">**/</span></code></pre>

<p> 原因是，我们可能调用了一个参数不是const的函数，而我们要传进去的实际参数确实const的，但是我们知道这个函数是不会对参数做修改的。于是我们就需要使用const_cast去除const限定，以便函数能够接受这个实际参数。 </p>
<pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Printer</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>* val,<span class="hljs-built_in">string</span> seperator = <span class="hljs-string">&quot;\n&quot;</span>)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-built_in">cout</span> &lt;&lt; val&lt;&lt; seperator;
&#125;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>
<span class="hljs-function"></span>&#123;    
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> consatant = <span class="hljs-number">20</span>;
    <span class="hljs-comment">//Printer(consatant);//Error: invalid conversion from &#x27;int&#x27; to &#x27;int*&#x27;</span>
    Printer(<span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-keyword">int</span> *&gt;(&amp;consatant));

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>

<h4 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h4><p>用于各种隐式转换，比如非const转const，void*转指针等, static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知；</p>
<h4 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h4><p><a target="_blank" rel="noopener" href="http://c.biancheng.net/cpp/biancheng/view/3297.html">http://c.biancheng.net/cpp/biancheng/view/3297.html</a></p>
<p>与类有关</p>
<p>用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。</p>
<p>向上转换：指的是子类向基类的转换</p>
<p>向下转换：指的是基类向子类的转换</p>
<p>它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。</p>
<h4 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h4><p>几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；</p>
<h5 id="为什么不使用C的强制转换？"><a href="#为什么不使用C的强制转换？" class="headerlink" title="为什么不使用C的强制转换？"></a>为什么不使用C的强制转换？</h5><p>C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。</p>
<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><h3 id="简单语句"><a href="#简单语句" class="headerlink" title="简单语句"></a>简单语句</h3><h4 id="空语句"><a href="#空语句" class="headerlink" title="空语句"></a>空语句</h4><p> ;    // 空语句 </p>
<h4 id="复合语句"><a href="#复合语句" class="headerlink" title="复合语句"></a>复合语句</h4><p> 复合语句是指用花括号括起来的（可能为空的）语句和声明的序列，复合语句也被称作块（block）。 </p>
<p> {} </p>
<h3 id="语句作用域"><a href="#语句作用域" class="headerlink" title="语句作用域"></a>语句作用域</h3><p> 定义在控制结构当中的变量只在相应语句的内部可见，一旦语句结束，变量就超出其作用范围。 </p>
<h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><h4 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h4><h4 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h4><p>case关键字和它对应的值一起被称为case标签。</p>
<p>case标签必须是整形常量表达式。</p>
<p>如果某个case标签匹配成功，将从该标签开始往后顺序执行所有case分支，除非程序显示的中断了这一过程。</p>
<p>dedault 标签：如果没有任何一个case标签能匹配上switch表达式的值，程序将执行紧跟在default标签后面的语句。</p>
<h3 id="迭代语句"><a href="#迭代语句" class="headerlink" title="迭代语句"></a>迭代语句</h3><p>（1）while 语句</p>
<pre><code class="hljs gauss"><span class="hljs-keyword">while</span> (condition)            statement</code></pre>

<p>（2）传统 for 语句</p>
<pre><code class="hljs mel"><span class="hljs-keyword">for</span> (initializar; <span class="hljs-keyword">condition</span>; <span class="hljs-keyword">expression</span>)        statement</code></pre>

<p>for 语句中定义的对象只在for循环体内可见。</p>
<p>（3）范围 for 语句</p>
<pre><code class="hljs less"><span class="hljs-selector-tag">for</span> (<span class="hljs-attribute">declaration </span>: expression)        <span class="hljs-selector-tag">statement</span></code></pre>

<p>（4）do while 语句</p>
<pre><code class="hljs lisp">do     statementwhile (<span class="hljs-name">condition</span>)</code></pre>

<h3 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h3><h4 id="break"><a href="#break" class="headerlink" title="break"></a><strong>break</strong></h4><p>break只能出现在迭代语句或者switch语句内部。仅限于终止离它最近的语句，然后从这些语句之后的第一条语句开始执行。</p>
<h4 id="continue"><a href="#continue" class="headerlink" title="continue"></a><strong>continue</strong></h4><p>continue语句终止最近的循环中的当前迭代并立即开始下一次迭代。</p>
<h4 id="goto"><a href="#goto" class="headerlink" title="goto"></a><strong>goto</strong></h4><p>goto的作用是从goto语句无条件跳转到同一函数内的另一条语句。</p>
<p>容易造成控制流混乱，应禁止使用。</p>
<h4 id="return"><a href="#return" class="headerlink" title="return"></a><strong>return</strong></h4><h3 id="try语句块和异常处理"><a href="#try语句块和异常处理" class="headerlink" title="try语句块和异常处理"></a>try语句块和异常处理</h3><p>C++中异常处理包括：throw表达式、try语句块。</p>
<p>try和catch，将一段可能抛出异常的语句序列括在花括号里构成try语句块。catch子句负责处理代码抛出的异常。</p>
<p>throw表达式语句，终止函数的执行。抛出一个异常，并把控制权转移到能处理该异常的最近的catch字句。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a><strong>函数</strong></h2><h3 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h3><h4 id="形参和实参："><a href="#形参和实参：" class="headerlink" title="形参和实参："></a>形参和实参：</h4><p>实参的类型必须与对应的形参类型匹配。</p>
<p>函数的调用规定实参数量应与形参数量一致。</p>
<h4 id="局部对象"><a href="#局部对象" class="headerlink" title="局部对象"></a>局部对象</h4><p>形参和参数体内部定义的变量统称为<strong>局部变量</strong>，它们对函数而言是”局部”的，仅在函数的作用域内可见，同时局部变量还会隐藏外层作用域中同名的其他变量。</p>
<p><strong>自动对象</strong>：只存在于块执行期间的对象。</p>
<p>局部静态对象：在程序的执行路径<strong>第一次经过对象定义语句时候进行初始化</strong>，并且直到程序终止才会被销毁。 </p>
<pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">count_calls</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> ctr = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> ++ctr;
&#125;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)
    &#123;
        <span class="hljs-built_in">cout</span> &lt;&lt; count_calls() &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 程序输出12345678910</span>
    &#125;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>

<h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><p>函数的三要素：（返回类型、函数名、形参类型）。</p>
<p>函数可被声明多次，但只能被定义一次。</p>
<h4 id="分离式编译"><a href="#分离式编译" class="headerlink" title="分离式编译"></a>分离式编译</h4><p>分离式编译允许把程序分割到几个文件中去，每个文件独立编译。</p>
<p>编译-&gt;链接</p>
<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>当形参是引用类型，这时它对应的实参被引用传递或者函数被传引用调用。</p>
<p>当实参被拷贝给形参，这样的实参被值传递或者函数被传值调用。</p>
<p>（1）传值参数</p>
<p>（2）被引用传参</p>
<p>（3）const形参和实参</p>
<p>（4）数组形参</p>
<p> 为函数传递一个数组时，实际上传递的是指向数组首元素的指针。 </p>
<p>void print(const int*);<br>void pring(const int[]);<br>void print(const int[10]);<br>// 以上三个函数等价 </p>
<p> 数组引用实参：f(int (&amp;arr)[10]) </p>
<pre><code class="hljs c++"><span class="hljs-keyword">int</span> *matrix[<span class="hljs-number">10</span>];   <span class="hljs-comment">// 10个指针构成的数组</span>
<span class="hljs-keyword">int</span> (*matrix)[<span class="hljs-number">10</span>]; <span class="hljs-comment">// 指向含有10个整数的数组的指针 </span></code></pre>

<p>（5）含有可变形参的数组</p>
<p>initializer_list</p>
<pre><code class="hljs reasonml"><span class="hljs-keyword">for</span> err<span class="hljs-constructor">_msg(<span class="hljs-params">initializer_list</span>&lt;<span class="hljs-params">string</span>&gt; <span class="hljs-params">li</span>)</span></code></pre>

<h4 id="返回类型和return语句"><a href="#返回类型和return语句" class="headerlink" title="返回类型和return语句"></a>返回类型和return语句</h4><p>2种：无返回值函数和右返回值函数。</p>
<pre><code class="hljs kotlin"><span class="hljs-keyword">return</span>;
<span class="hljs-keyword">return</span> expression;</code></pre>

<p>函数完成后，它所占用的存储空间也会随着被释放掉。</p>
<p>返回局部对象的引用是错误的；返回局部对象的指针也是错误的。 </p>
<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>重载函数：同一作用域内的几个函数名字相同但形参列表不通，我们称之为重载函数。（overloaded）。</p>
<p><strong>不允许2个函数除了返回类型外其他所有的要素都相同。</strong></p>
<h4 id="重载与作用域"><a href="#重载与作用域" class="headerlink" title="重载与作用域"></a>重载与作用域</h4><p>如果在内存作用域中声明名字，它将隐藏外层作用域中声明的同名实体。</p>
<h3 id="特殊用途语言特性"><a href="#特殊用途语言特性" class="headerlink" title="特殊用途语言特性"></a>特殊用途语言特性</h3><p>（1）默认实参</p>
<p>函数调用时，实参按其位置解析，默认实参负责填补函数调用缺少的尾部实参。</p>
<pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">string</span>::size_type sz;
<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">screen</span><span class="hljs-params">(sz ht = <span class="hljs-number">24</span>, sz wid = <span class="hljs-number">80</span>, <span class="hljs-keyword">char</span> background = <span class="hljs-string">&#x27; &#x27;</span>)</span></span>;</code></pre>

<p>::: tip</p>
<p>当设计含有默认实参的函数时，需要合理设置形参的顺序。一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。</p>
<p>:::</p>
<p>（2）内联函数</p>
<p>使用关键词inline来声明内联函数。</p>
<p>内联用于<strong>优化规模较小，流程直接，频繁调用的函数</strong>。</p>
<p>（3）constexpr函数</p>
<p>constexpr函数是指能用于常量表达式的函数。</p>
<h3 id="函数匹配"><a href="#函数匹配" class="headerlink" title="函数匹配"></a>函数匹配</h3><p>Step1:确定候选函数和可选函数。</p>
<p>Step2:寻找最佳匹配。</p>
<h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">useBigger</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s1, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s2, <span class="hljs-keyword">bool</span> pf(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;))</span></span>;
等价于
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">useBigger</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s1, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s2, <span class="hljs-keyword">bool</span> (*pf)(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;))</span></span>;</code></pre>

<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类的基本思想是<strong>数据抽象和封装</strong>。</p>
<p>抽象是一种依赖于接口和实现分离的编程技术。</p>
<p>封装实现了类的接口和实现的分离。</p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/c/">c++</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/c/">c++</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2021/04/14/leetcode/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">leetcode</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2021/04/08/c++core-guidelines/">
                        <span class="hidden-mobile">c++core-guidelines</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>





  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















</body>
</html>
