<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>lecture 1-shell</title>
    <link href="/2020/12/08/missing/lecture-1/"/>
    <url>/2020/12/08/missing/lecture-1/</url>
    
    <content type="html"><![CDATA[<h2 id="在程序间创建连接"><a href="#在程序间创建连接" class="headerlink" title="在程序间创建连接"></a>在程序间创建连接</h2><p>信息的流动称为<strong>流</strong>，程序中存在两个流。</p><p>流入程序的称为<strong>输入流</strong>，流出的则称为<strong>输出流</strong>。</p><p>程序读取信息时会从输入流中进行读取，相反打印信息时则是输出到输出流中。</p><p>例如重定向 &gt; 可以将程序的输入流和输出流分别重定向到文件中。</p><blockquote><p>最简单的重定向是 &lt; file 和 &gt; file。这两个命令可以将程序的输入输出流分别重定向到文件：</p></blockquote><pre><code class="hljs sh">$ <span class="hljs-built_in">echo</span> hello &gt; hello.txt$ cat hello.txthello$ cat &lt; hello.txt &gt; hello2.txt$ cat hello2.txthello</code></pre><p>&gt;&gt; 表示追加内容(append)。</p><pre><code class="hljs sh">$ cat hello.txthello$ <span class="hljs-built_in">echo</span> hello &gt;&gt; hello.txt$ cat hello.txthellohello</code></pre><blockquote><p>使用管道（ pipes ），我们能够更好的利用文件重定向。 |操作符允许我们将一个程序的输出和另外一个程序的输入连接起来。</p></blockquote><p>管道线的用法实例。 </p>]]></content>
    
    
    <categories>
      
      <category>missing</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>lecture2 - Shell Tools and Scripting</title>
    <link href="/2020/12/08/missing/lecture-2/"/>
    <url>/2020/12/08/missing/lecture-2/</url>
    
    <content type="html"><![CDATA[<h2 id="shell-脚本"><a href="#shell-脚本" class="headerlink" title="shell 脚本"></a>shell 脚本</h2><h3 id="不要有空格"><a href="#不要有空格" class="headerlink" title="不要有空格"></a>不要有空格</h3><p>To assign variables in bash, use the syntax <code>foo=bar</code> and access the value of the variable with <code>$foo</code>. <strong>Note that <code>foo = bar</code> will not work</strong> since it is interpreted as calling the <code>foo</code> program with arguments <code>=</code> and <code>bar</code>. In general, in shell scripts the space character will perform argument splitting. This behavior can be confusing to use at first, so always check for that.</p><h3 id="单引号和双引号"><a href="#单引号和双引号" class="headerlink" title="单引号和双引号"></a>单引号和双引号</h3><p>单引号内部的内容会原样输出。双引号则会进行相应的替换:</p><p>Strings in bash can be defined with <code>&#39;</code> and <code>&quot;</code> delimiters, but they are not equivalent. Strings delimited with <code>&#39;</code> are literal strings and will not substitute variable values whereas <code>&quot;</code> delimited strings will. </p><pre><code class="hljs bash">foo=bar<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$foo</span>&quot;</span><span class="hljs-comment"># prints bar</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;$foo&#x27;</span><span class="hljs-comment"># prints $foo</span></code></pre><h2 id="号"><a href="#号" class="headerlink" title="$号"></a>$号</h2><ul><li><code>$0</code> - Name of the script</li><li><code>$1</code> to <code>$9</code> - Arguments to the script. <code>$1</code> is the first argument and so on.</li><li><code>$@</code> - All the arguments</li><li><code>$#</code> - Number of arguments</li><li><code>$?</code> - Return code of the previous command</li><li><code>$$</code> - Process identification number (PID) for the current script</li><li><code>!!</code> - Entire last command, including arguments. A common pattern is to execute a command only for it to fail due to missing permissions; you can quickly re-execute the command with sudo by doing <code>sudo !!</code></li><li><code>$_</code> - Last argument from the last command. If you are in an interactive shell, you can also quickly get this value by typing <code>Esc</code> followed by <code>.</code></li></ul><h2 id="short-circuiting-operators-逻辑短路符号"><a href="#short-circuiting-operators-逻辑短路符号" class="headerlink" title="short-circuiting operators 逻辑短路符号"></a>short-circuiting operators 逻辑短路符号</h2><pre><code class="hljs shell">false || echo &quot;Oops, fail&quot;<span class="hljs-meta">#</span><span class="bash"> Oops, fail</span>true || echo &quot;Will not be printed&quot;<span class="hljs-meta">#</span>true &amp;&amp; echo &quot;Things went well&quot;<span class="hljs-meta">#</span><span class="bash"> Things went well</span>false &amp;&amp; echo &quot;Will not be printed&quot;<span class="hljs-meta">#</span>true ; echo &quot;This will always run&quot;<span class="hljs-meta">#</span><span class="bash"> This will always run</span>false ; echo &quot;This will always run&quot;<span class="hljs-meta">#</span><span class="bash"> This will always run</span></code></pre><h2 id="大括号"><a href="#大括号" class="headerlink" title="{} 大括号"></a>{} 大括号</h2><pre><code class="hljs bash">convert image.&#123;png,jpg&#125;<span class="hljs-comment"># Will expand to</span>convert image.png image.jpgcp /path/to/project/&#123;foo,bar,baz&#125;.sh /newpath<span class="hljs-comment"># Will expand to</span>cp /path/to/project/foo.sh /path/to/project/bar.sh /path/to/project/baz.sh /newpath<span class="hljs-comment"># Globbing techniques can also be combined</span>mv *&#123;.py,.sh&#125; folder<span class="hljs-comment"># Will move all *.py and *.sh files</span>mkdir foo bar<span class="hljs-comment"># This creates files foo/a, foo/b, ... foo/h, bar/a, bar/b, ... bar/h</span>touch &#123;foo,bar&#125;/&#123;a..h&#125;touch foo/x bar/y<span class="hljs-comment"># Show differences between files in foo and bar</span>diff &lt;(ls foo) &lt;(ls bar)<span class="hljs-comment"># Outputs</span><span class="hljs-comment"># &lt; x</span><span class="hljs-comment"># ---</span><span class="hljs-comment"># &gt; y</span></code></pre><h2 id="find：查找文件命令"><a href="#find：查找文件命令" class="headerlink" title="find：查找文件命令"></a>find：查找文件命令</h2><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> Find all directories named src</span>find . -name src -type d<span class="hljs-meta">#</span><span class="bash"> Find all python files that have a folder named <span class="hljs-built_in">test</span> <span class="hljs-keyword">in</span> their path</span>find . -path &#x27;*/test/*.py&#x27; -type f<span class="hljs-meta">#</span><span class="bash"> Find all files modified <span class="hljs-keyword">in</span> the last day</span>find . -mtime -1<span class="hljs-meta">#</span><span class="bash"> Find all zip files with size <span class="hljs-keyword">in</span> range 500k to 10M</span>find . -size +500k -size -10M -name &#x27;*.tar.gz&#x27;</code></pre><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> Delete all files with .tmp extension</span>find . -name &#x27;*.tmp&#x27; -exec rm &#123;&#125; \;<span class="hljs-meta">#</span><span class="bash"> Find all PNG files and convert them to JPG</span>find . -name &#x27;*.png&#x27; -exec convert &#123;&#125; &#123;&#125;.jpg \;</code></pre><h2 id="查找代码"><a href="#查找代码" class="headerlink" title="查找代码"></a>查找代码</h2><p>grep<br>  -C: 获取查找结果的上下文。(Context)<br>  -v：对结果进行反选，即输出不匹配的结果。 (Invert)<br>  -C 5 ： 输出匹配结果的前后 5 行 。<br>  -R： 递归进入子目录并搜索所有文本文件。</p><pre><code class="hljs bash"><span class="hljs-comment"># 查找所有使用了 requests 库的文件</span>rg -t py <span class="hljs-string">&#x27;import requests&#x27;</span><span class="hljs-comment"># 查找所有没有写 shebang 的文件（包含隐藏文件）</span>rg -u --files-without-match <span class="hljs-string">&quot;^#!&quot;</span><span class="hljs-comment"># 查找所有的foo字符串，并打印其之后的5行</span>rg foo -A 5<span class="hljs-comment"># 打印匹配的统计信息（匹配的行和文件的数量）</span>rg --stats PATTERN</code></pre><h2 id="文件夹导航"><a href="#文件夹导航" class="headerlink" title="文件夹导航"></a>文件夹导航</h2><p>nnn命令和ranger命令</p>]]></content>
    
    
    <categories>
      
      <category>missing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sdfds</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/12/08/hello/"/>
    <url>/2020/12/08/hello/</url>
    
    <content type="html"><![CDATA[<p>hello everyone</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
