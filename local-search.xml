<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>leetcode</title>
    <link href="/2021/04/14/leetcode/"/>
    <url>/2021/04/14/leetcode/</url>
    
    <content type="html"><![CDATA[<h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><p>763</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>cpp-primer</title>
    <link href="/2021/04/08/cpp-primer/"/>
    <url>/2021/04/08/cpp-primer/</url>
    
    <content type="html"><![CDATA[<h2 id="第一章-开始"><a href="#第一章-开始" class="headerlink" title="第一章 开始"></a>第一章 开始</h2><h3 id="1-1-编写一个简单的C-程序"><a href="#1-1-编写一个简单的C-程序" class="headerlink" title="1.1 编写一个简单的C++程序"></a>1.1 编写一个简单的C++程序</h3><p> 每个C++程序都包含一个或多个函数，其中一个必须命名为main. </p><h3 id="1-2-初识输入输出"><a href="#1-2-初识输入输出" class="headerlink" title="1.2 初识输入输出"></a>1.2 初识输入输出</h3><table><thead><tr><th><strong>对象</strong></th><th><strong>用途</strong></th></tr></thead><tbody><tr><td>cin</td><td>标准输入</td></tr><tr><td>cout</td><td>标准输出</td></tr><tr><td>cerr</td><td>标准错误</td></tr><tr><td>clog</td><td>输出运行时的一般性消息</td></tr></tbody></table><h3 id="1-3-注释简介"><a href="#1-3-注释简介" class="headerlink" title="1.3 注释简介"></a>1.3 注释简介</h3><p>两种：</p><p>单行注释：//</p><p>界定符：/* 和 */</p><h3 id="1-4-控制流"><a href="#1-4-控制流" class="headerlink" title="1.4 控制流"></a>1.4 控制流</h3><p>while;for;if;</p><h2 id="第二章-变量和基本类型"><a href="#第二章-变量和基本类型" class="headerlink" title="第二章 变量和基本类型"></a>第二章 变量和基本类型</h2><p> 不要混用符号类型和无符号类型。 </p><table><thead><tr><th align="center">类型</th><th align="center">位</th><th align="left">范围</th></tr></thead><tbody><tr><td align="center">char</td><td align="center">1 个字节</td><td align="left">-128 到 127 或者 0 到 255</td></tr><tr><td align="center">unsigned char</td><td align="center">1 个字节</td><td align="left">0 到 255</td></tr><tr><td align="center">signed char</td><td align="center">1 个字节</td><td align="left">-128 到 127</td></tr><tr><td align="center">int</td><td align="center">4 个字节</td><td align="left">-2147483648 到 2147483647</td></tr><tr><td align="center">unsigned int</td><td align="center">4 个字节</td><td align="left">0 到 4294967295</td></tr><tr><td align="center">signed int</td><td align="center">4 个字节</td><td align="left">-2147483648 到 2147483647</td></tr><tr><td align="center">short int</td><td align="center">2 个字节</td><td align="left">-32768 到 32767</td></tr><tr><td align="center">unsigned short int</td><td align="center">2 个字节</td><td align="left">0 到 65,535</td></tr><tr><td align="center">signed short int</td><td align="center">2 个字节</td><td align="left">-32768 到 32767</td></tr><tr><td align="center">long int</td><td align="center">8 个字节</td><td align="left">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td></tr><tr><td align="center">signed long int</td><td align="center">8 个字节</td><td align="left">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td></tr><tr><td align="center">unsigned long int</td><td align="center">8 个字节</td><td align="left">0 到 18,446,744,073,709,551,615</td></tr><tr><td align="center">float</td><td align="center">4 个字节</td><td align="left">精度型占4个字节（32位）内存空间，+/- 3.4e +/- 38 (~7 个数字)</td></tr><tr><td align="center">double</td><td align="center">8 个字节</td><td align="left">双精度型占8 个字节（64位）内存空间，+/- 1.7e +/- 308 (~15 个数字)</td></tr><tr><td align="center">long double</td><td align="center">16 个字节</td><td align="left">长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。</td></tr><tr><td align="center">wchar_t</td><td align="center">2 或 4 个字节</td><td align="left">1 个宽字符</td></tr></tbody></table><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><h4 id="基本形式："><a href="#基本形式：" class="headerlink" title="基本形式："></a>基本形式：</h4><p>类型说明符，随后紧跟着一个或者多个变量名组成的列表，其中变量名以逗号分隔，最后以分号结束。</p><h4 id="初始值"><a href="#初始值" class="headerlink" title="初始值"></a>初始值</h4><p>初始化和赋值是2个完全不同的操作。初始化的含义是创建变量的时候赋予一个初始值，而赋值的含义是把对象的当前值擦除，用一个新值来替代。两者区别很小。</p><h4 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h4><p>用花括号来初始化变量的方式，称为列表初始化。</p><h4 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a>默认初始化</h4><p>如果定义变量没有指定初始值，则变量被默认初始化。</p><p>:::tips<br>例外情况：<br>定义在函数体内部的内置类型变量将不被初始化，其值未定义。<br>建议初始化每个内置类型的变量。<br>:::</p><h3 id="变量声明和定义的关系"><a href="#变量声明和定义的关系" class="headerlink" title="变量声明和定义的关系"></a>变量声明和定义的关系</h3><h4 id="变量声明："><a href="#变量声明：" class="headerlink" title="变量声明："></a>变量声明：</h4><p>​    规定了变量的类型和名字。</p><h4 id="变量定义："><a href="#变量定义：" class="headerlink" title="变量定义："></a>变量定义：</h4><p>​    除声明之外，还需要申请存储空间。</p><p> 如果想声明一个变量，而非定义它，需要使用extern关键词。 </p><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> i;   <span class="hljs-comment">// 声明i而非定义i</span><span class="hljs-keyword">int</span> j;      <span class="hljs-comment">// 声明并定义j </span></code></pre><p> ::: tip变量只能被定义一次，但可以被多次声明。::: </p><h4 id="名字的作用域"><a href="#名字的作用域" class="headerlink" title="名字的作用域"></a>名字的作用域</h4><p>作用域：C++中大多数作用域都用花括号分隔。</p><p>作用域中一旦声明了某个名字，它所嵌套的所有作用域都能访问该名字。同时，<strong>允许在内层作用域中重新定义外层作用域中有的名字。</strong></p><p>::: warning如果函数有可能用到某全局变量，则不宜再定义一个同名的局部变量。:::</p><h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><p> 定义:复合类型是基于其他类型定义的类型。 </p><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>引用：为对象起另外一个名字。 </p><p> ::: warning引用必须被初始化。引用本身不是对象，所以不能定义引用的引用。引用要和绑定的对象严格匹配。引用类型的初始值，必须是一个对象。::: </p><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><p>指针：本身就是一个对象。允许对指针赋值和拷贝。指针无须在定义的时候赋值。</p><p>（1）利用指针访问对象</p><p>如果指针指向了一个对象，则允许使用解引用符（*）来访问该对象。</p><p>（2）void* 指针</p><p> The void pointer in C is a pointer which is not associated with any data types. It points to some dat location in the storage means points to the address of variables. It is also called general purpose pointer. In C, malloc() and calloc() functions return void * or generic pointers. </p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-keyword">int</span> a = <span class="hljs-number">7</span>;   <span class="hljs-keyword">float</span> b = <span class="hljs-number">7.6</span>;   <span class="hljs-keyword">void</span> *p;   p = &amp;a;   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Integer variable is = %d&quot;</span>, *( (<span class="hljs-keyword">int</span>*) p) );   p = &amp;b;   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nFloat variable is = %f&quot;</span>, *( (<span class="hljs-keyword">float</span>*) p) );   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="理解符合类型的声明"><a href="#理解符合类型的声明" class="headerlink" title="理解符合类型的声明"></a>理解符合类型的声明</h4><h5 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h5><p>** 表示指向指针的指针</p><p>*** 表示指向指针的指针的指针</p><h4 id="指向指针的引用"><a href="#指向指针的引用" class="headerlink" title="指向指针的引用"></a>指向指针的引用</h4><p>不能定义指向引用的指针。但指针是对象，所以存在对指针的引用。</p><h3 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h3><p> 定义：const用于定义一个变量，它的值不能被改变。const对象必须初始化。 </p><p>::: tip </p><p>    编译器将在编译过程中把用 到该变量的地方都替换成对应的值，如果程序包含多个文件，则每个用了const 对象的文件都应可以访问到他的初始值。为了支持这个用法， 同时避免对同一变量的重复定义，默认情况下，const对象仅设定为仅在文件内有效。<br>    为了让const对象在多个文件均可共享，解决办法是，对于const 变量不管是声明还是定义都添加extern关键字。</p><p>:::</p><h4 id="const的引用"><a href="#const的引用" class="headerlink" title="const的引用"></a>const的引用</h4><p>允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式。一般，引用的类型必须与其所引用对象的类型一致，特殊情况是表达式。</p><h4 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h4><p> 弄清楚类型，可以从右边往左边阅读。 </p><ul><li>const 修饰指针指向的内容，则内容为不可变量。 </li></ul><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *p = <span class="hljs-number">8</span>;</code></pre><p>则指针指向的内容数值 <code>8</code> 不可改变。简称左定值，因为 const 位于 * 号的左边。</p><ul><li>const 修饰指针，则指针为不可变量。 </li></ul><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> a = <span class="hljs-number">8</span>;<span class="hljs-keyword">int</span>* <span class="hljs-keyword">const</span> p = &amp;a;*p = <span class="hljs-number">9</span>; <span class="hljs-comment">// 正确</span><span class="hljs-keyword">int</span>  b = <span class="hljs-number">7</span>;p = &amp;b; <span class="hljs-comment">// 错误</span></code></pre><ul><li>const 修饰指针和指针指向的内容，则指针和指针指向的内容都为不可变量。 </li></ul><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> a = <span class="hljs-number">8</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> * <span class="hljs-keyword">const</span>  p = &amp;a;</code></pre><p>这种情况是上两种情况的结合， 即指针与指向的内容和指针指向的内存地址都不可变</p><p> <strong>“左定值，右定向，const修饰不变量”</strong> </p><h4 id="常量函数"><a href="#常量函数" class="headerlink" title="常量函数"></a>常量函数</h4><p> &lt;类型说明符&gt;&lt;函数名&gt;(&lt;参数表&gt;)const; </p><p>要注意的是，修饰符const要加在函数说明的尾部（若放在首部的话，则是对函数返回值的修饰,即返回值是const），它是函数类型的一部分。</p><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> me;<span class="hljs-keyword">int</span> readme <span class="hljs-keyword">const</span> &#123; <span class="hljs-comment">// 常量函数 </span>    <span class="hljs-keyword">return</span> me;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">writeme</span><span class="hljs-params">()</span> </span>&#123;     me = <span class="hljs-number">1</span>; &#125; </code></pre><p>当一个函数被const说明后，其函数中出现的对外部数据的<strong>任何写入或修改都将被系统检查为出错</strong>。如果把函数writeme()说明为：</p><pre><code class="hljs cpp\">void writeme() const &#123;    me &#x3D; 1; &#125;   </code></pre><h4 id="const修饰类成员函数"><a href="#const修饰类成员函数" class="headerlink" title="const修饰类成员函数"></a>const修饰类成员函数</h4><p> const 修饰类成员函数，其目的是防止成员函数修改被调用对象的值，如果我们不想修改一个调用对象的值，所有的成员函数都应当声明为 const 成员函数。 </p><p> <strong>注意：</strong>const 关键字不能与 static 关键字同时使用，因为 static 关键字修饰静态成员函数，静态成员函数不含有 this 指针，即不能实例化，const 成员函数必须具体到某一实例。 </p><p>  值得注意的是，把一个成员函数声明为const可以保证这个成员函数不修改数据成员，但是，如果据成员是指针，则const成员函数并不能保证不修改指针指向的对象，编译器不会把这种修改检测为错误。例如， </p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Name</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s)</span> <span class="hljs-keyword">const</span></span>;<span class="hljs-keyword">private</span>:    <span class="hljs-keyword">char</span> *m_sName;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s)</span> <span class="hljs-keyword">const</span> </span>&#123;    m_sName = s.c_str();      <span class="hljs-comment">// 错误！不能修改m_sName;</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.size(); ++i)         m_sName[i] = s[i];    <span class="hljs-comment">// 不好的风格，但不是错误的</span>&#125;</code></pre><p>const成员函数可以被具有相同参数列表的非const成员函数重载，例如，</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Screen</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> <span class="hljs-keyword">const</span></span>;&#125;;</code></pre><p>​    在这种情况下，类对象的常量性决定调用哪个函数。 </p><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> Screen cs;Screen cc2;<span class="hljs-keyword">char</span> ch = cs.get(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 调用const成员函数</span>ch = cs2.get(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);     <span class="hljs-comment">// 调用非const成员函数</span></code></pre><h4 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h4><p><a href="https://stackoverflow.com/questions/14116003/difference-between-constexpr-and-const">https://stackoverflow.com/questions/14116003/difference-between-constexpr-and-const</a></p><h3 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h3><h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><p> 两种方法用于定义类型别名： </p><p> （1）使用关键词typedef </p><pre><code class="hljs angelscript"><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">double</span> wages; <span class="hljs-comment">//wages是double的同义词</span><span class="hljs-keyword">typedef</span> wages *p; <span class="hljs-comment">// p是double*的同义词</span></code></pre><p> （2）别名声明 </p><pre><code class="hljs c++"><span class="hljs-keyword">using</span> SI = Sales_item;  <span class="hljs-comment">// SI是Sales_item的同义词</span></code></pre><p>auto类型说明符：让编译器通过初始值来推算变量的类型。</p><p>decltype类型指示符：选择并返回操作符的数据类型。只得到类型，不实际计算表达式的值。</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> i = <span class="hljs-number">4</span>;<span class="hljs-keyword">decltype</span>(i) a; <span class="hljs-comment">//推导结果为int。a的类型为int。</span></code></pre><h3 id="自定义数据结构"><a href="#自定义数据结构" class="headerlink" title="自定义数据结构"></a>自定义数据结构</h3><p>（1）类</p><p>数据结构是把一组相关的数据元素组织起来，然后使用它们的策略和方法。</p><p>类一般不定义在函数体内，为了确保各个文件中类的定义一致，类通常被定义在头文件中，而且类所在头文件的名字应该与类的名字一样。</p><p>头文件通常包含那些被定义一次的实体。</p><p>（2）预处理器</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> SALES_DATA_H</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SALES_DATA_H</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre><p>一般把预处理变量的名字全部大写。</p><h2 id="字符串、向量和数组"><a href="#字符串、向量和数组" class="headerlink" title="字符串、向量和数组"></a><strong>字符串、向量和数组</strong></h2><p> string表示可变长的字符序列，vector存放的是某种给定类型对象的可变长序列。 </p><h3 id="命名空间的-using-声明"><a href="#命名空间的-using-声明" class="headerlink" title="命名空间的 using 声明"></a>命名空间的 using 声明</h3><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>:name; </code></pre><p> <strong>头文件不应包含using声明。</strong> </p><h3 id="标准库类型-string"><a href="#标准库类型-string" class="headerlink" title="标准库类型 string"></a>标准库类型 string</h3><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</code></pre><h4 id="定义和初始化"><a href="#定义和初始化" class="headerlink" title="定义和初始化"></a>定义和初始化</h4><pre><code class="hljs cpp"><span class="hljs-built_in">string</span> s1;<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s2</span><span class="hljs-params">(s1)</span></span>;<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s3</span><span class="hljs-params">(<span class="hljs-string">&quot;value&quot;</span>)</span></span>;s3 = <span class="hljs-string">&quot;value&quot;</span>;<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s4</span><span class="hljs-params">(n, <span class="hljs-string">&#x27;c&#x27;</span>)</span></span>;  <span class="hljs-comment">// n个c</span></code></pre><h4 id="string对象的操作"><a href="#string对象的操作" class="headerlink" title="string对象的操作"></a>string对象的操作</h4><pre><code class="hljs cpp">s.empty();      <span class="hljs-comment">// 判空</span>s.size();       <span class="hljs-comment">// 字符个数</span>s[n];           <span class="hljs-comment">// s中第n个字符的引用</span>s1+s2;          <span class="hljs-comment">// s1和s2连接</span>&lt;,&lt;=,&gt;,&gt;=       <span class="hljs-comment">// 比较</span></code></pre><h4 id="处理string对象中的字符-遍历给定序列中的每个值执行某种操作"><a href="#处理string对象中的字符-遍历给定序列中的每个值执行某种操作" class="headerlink" title="处理string对象中的字符 遍历给定序列中的每个值执行某种操作"></a>处理string对象中的字符 遍历给定序列中的每个值执行某种操作</h4><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (declaration : expression)           statement</code></pre><h3 id="标准库类型-vector"><a href="#标准库类型-vector" class="headerlink" title="标准库类型 vector"></a>标准库类型 vector</h3><p>标准库vector表示对象的集合，其中所有对象的类型都相同。</p><p>vector是一个类模板，而不是类型。</p><h4 id="定义和初始化vector对象"><a href="#定义和初始化vector对象" class="headerlink" title="定义和初始化vector对象"></a>定义和初始化vector对象</h4><pre><code class="hljs cpp"><span class="hljs-built_in">vector</span>&lt;T&gt; v1;<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;T&gt; <span class="hljs-title">v2</span><span class="hljs-params">(v1)</span></span>;<span class="hljs-built_in">vector</span>&lt;T&gt; v2 = v1;<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;T&gt; <span class="hljs-title">v3</span><span class="hljs-params">(n, val)</span></span>;<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;T&gt; <span class="hljs-title">v4</span><span class="hljs-params">(n)</span></span>;<span class="hljs-built_in">vector</span>&lt;T&gt; v5&#123;a,b,c...&#125;vecrot&lt;T&gt; v5=&#123;a,b,c...&#125; </code></pre><p> 如果用圆括号，那么提供的值是用来构造vector对象的。 </p><p> 如果用花括号，则是使用列表初始化该vector对象。 </p><h4 id="向vector对象添加元素"><a href="#向vector对象添加元素" class="headerlink" title="向vector对象添加元素"></a>向vector对象添加元素</h4><p> 先定义一个空的vector对象，在运行的时候使用**push_back()**向其中添加。 </p><h4 id="其他vector操作"><a href="#其他vector操作" class="headerlink" title="其他vector操作"></a>其他vector操作</h4><pre><code class="hljs c++">v.empty();v.<span class="hljs-built_in">size</span>();v.push_back(t);v[n];</code></pre><h3 id="迭代器介绍"><a href="#迭代器介绍" class="headerlink" title="迭代器介绍"></a>迭代器介绍</h3><h4 id="迭代器运算符"><a href="#迭代器运算符" class="headerlink" title="迭代器运算符"></a>迭代器运算符</h4><pre><code class="hljs cpp">*iter            <span class="hljs-comment">// 解引用，返回引用</span>iter-&gt;mem        <span class="hljs-comment">// 等价于  (*iter).mem</span>++iter--iteriter1 == iter2iter1 != iter2iter + niter - niter += niter -= niter1 - iter2     <span class="hljs-comment">// 两个迭代器相减的结果是它们之间的距离</span>&gt;, &gt;=, &lt;, &lt;=      <span class="hljs-comment">// 位置比较</span></code></pre><p>::: warning</p><p>凡是使用了迭代器的循环体，都不能向迭代器所属的容器添加元素。</p><p>:::</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p> 数组、指针 </p><p> 使用数组下标的时候，通常将其定义为size_t类型。 </p><p>不存在引用的数组。</p><p>如果两个指针分别指向不相关的对象，则不能进行对这2个指针进行比较。</p><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p><strong>begin</strong> string和vector的成员，返回指向第一个元素的迭代器。也是一个标准库函数，输入一个数组，返回指向该数组首元素的指针。</p><p><strong>end</strong> string和vector的成员，返回一个尾后迭代器。也是一个标准库函数，输入一个数组，返回指向该数组尾元素的下一个位置的指针。</p><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p><strong>重载运算符</strong>：为已经存在的运算符赋予了另外一层含义。</p><p><strong>右值：</strong> 当一个对象用作右值得时候，用的是对象的<strong>值</strong>（内容）。</p><p><strong>左值：</strong> 当对象被用作左值得时候，用的是对象的<strong>身份</strong>（在内存中的位置）。</p><p><strong>左值 (lvalue, locator value)</strong> 表示了一个占据内存中某个可识别的位置（也就是一个地址）的对象。</p><p><strong>右值 (rvalue)</strong> 则使用排除法来定义。一个表达式不是 <em>左值</em> 就是 <em>右值</em> 。 那么，右值是一个 <em>不</em> 表示内存中某个可识别位置的对象的表达式。</p><p><a href="https://nettee.github.io/posts/2018/Understanding-lvalues-and-rvalues-in-C-and-C/">https://nettee.github.io/posts/2018/Understanding-lvalues-and-rvalues-in-C-and-C/</a></p><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p> %： 参与取余运算的运算对象必须是<strong>整数</strong>类型。 </p><h3 id="逻辑和关系运算符"><a href="#逻辑和关系运算符" class="headerlink" title="逻辑和关系运算符"></a>逻辑和关系运算符</h3><table><thead><tr><th align="center">运算符</th></tr></thead><tbody><tr><td align="center">!</td></tr><tr><td align="center">&lt;</td></tr><tr><td align="center">&lt;=</td></tr><tr><td align="center">&gt;</td></tr><tr><td align="center">&gt;=</td></tr><tr><td align="center">==</td></tr><tr><td align="center">!=</td></tr><tr><td align="center">&amp;&amp;</td></tr><tr><td align="center">||</td></tr></tbody></table><p> &amp;&amp; 运算符和 || 运算符都是先求左侧运算对象的值再求右侧运算对象的值。 </p><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>赋值运算符满足右结合律。</p><p>不要混淆相等运算符和赋值运算符</p><h3 id="递增和递减运算符"><a href="#递增和递减运算符" class="headerlink" title="递增和递减运算符"></a>递增和递减运算符</h3><p>递增运算符 ++</p><p>递减运算符 –</p><h3 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h3><p> 点运算符和箭头运算符 </p><pre><code class="hljs c++">n = (*p).<span class="hljs-built_in">size</span>();n = p-&gt;<span class="hljs-built_in">size</span>(); </code></pre><h3 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h3><pre><code class="hljs cpp">condition ? expression1 : expression2; </code></pre><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9UZFZFlIibIBPK52gb5KatGRPVOxJAJkwamf6aT5Qlb7icLmA1kzjEvqxl9ibIwWeLlT2OcuhkLaM1Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h3 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h3><p> sizeof运算符返回一条表达式或一个类型名字所占的字节数，其所得值是一个size_t类型，是一个常量表达式。 </p><pre><code class="hljs c++"><span class="hljs-keyword">sizeof</span> (type)<span class="hljs-keyword">sizeof</span> expr</code></pre><h3 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h3><p> 逗号运算符含有两个运算对象，按照从左向右的顺序依次求值。 </p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><h4 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h4><h4 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h4><p>C++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast</p><h4 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h4><p>用于将const变量转为非const</p><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> constant = <span class="hljs-number">21</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>* const_p = &amp;constant;<span class="hljs-keyword">int</span>* modifier = <span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-keyword">int</span>*&gt;(const_p);*modifier = <span class="hljs-number">7</span>;<span class="hljs-built_in">cout</span> &lt;&lt; constant &lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;  *modifier &lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;constant: &quot;</span> &lt;&lt; constant &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;const_p: &quot;</span> &lt;&lt; *const_p &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;modifier: &quot;</span> &lt;&lt; *modifier &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;constant: &quot;</span> &lt;&lt; &amp;constant &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;const_p: &quot;</span> &lt;&lt; const_p &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;modifier: &quot;</span> &lt;&lt; modifier &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-comment">/**</span><span class="hljs-comment">注意constant的值还是21， *modifier值变成了7</span><span class="hljs-comment">并且&amp;constant、const_p、modifier指向的地址相同</span><span class="hljs-comment">**/</span></code></pre><p> 原因是，我们可能调用了一个参数不是const的函数，而我们要传进去的实际参数确实const的，但是我们知道这个函数是不会对参数做修改的。于是我们就需要使用const_cast去除const限定，以便函数能够接受这个实际参数。 </p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Printer</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>* val,<span class="hljs-built_in">string</span> seperator = <span class="hljs-string">&quot;\n&quot;</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; val&lt;&lt; seperator;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span><span class="hljs-function"></span>&#123;        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> consatant = <span class="hljs-number">20</span>;    <span class="hljs-comment">//Printer(consatant);//Error: invalid conversion from &#x27;int&#x27; to &#x27;int*&#x27;</span>    Printer(<span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-keyword">int</span> *&gt;(&amp;consatant));    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h4><p>用于各种隐式转换，比如非const转const，void*转指针等, static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知；</p><h4 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h4><p><a href="http://c.biancheng.net/cpp/biancheng/view/3297.html">http://c.biancheng.net/cpp/biancheng/view/3297.html</a></p><p>与类有关</p><p>用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。</p><p>向上转换：指的是子类向基类的转换</p><p>向下转换：指的是基类向子类的转换</p><p>它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。</p><h4 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h4><p>几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；</p><h5 id="为什么不使用C的强制转换？"><a href="#为什么不使用C的强制转换？" class="headerlink" title="为什么不使用C的强制转换？"></a>为什么不使用C的强制转换？</h5><p>C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。</p><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><h3 id="简单语句"><a href="#简单语句" class="headerlink" title="简单语句"></a>简单语句</h3><h4 id="空语句"><a href="#空语句" class="headerlink" title="空语句"></a>空语句</h4><p> ;    // 空语句 </p><h4 id="复合语句"><a href="#复合语句" class="headerlink" title="复合语句"></a>复合语句</h4><p> 复合语句是指用花括号括起来的（可能为空的）语句和声明的序列，复合语句也被称作块（block）。 </p><p> {} </p><h3 id="语句作用域"><a href="#语句作用域" class="headerlink" title="语句作用域"></a>语句作用域</h3><p> 定义在控制结构当中的变量只在相应语句的内部可见，一旦语句结束，变量就超出其作用范围。 </p><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><h4 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h4><h4 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h4><p>case关键字和它对应的值一起被称为case标签。</p><p>case标签必须是整形常量表达式。</p><p>如果某个case标签匹配成功，将从该标签开始往后顺序执行所有case分支，除非程序显示的中断了这一过程。</p><p>dedault 标签：如果没有任何一个case标签能匹配上switch表达式的值，程序将执行紧跟在default标签后面的语句。</p><h3 id="迭代语句"><a href="#迭代语句" class="headerlink" title="迭代语句"></a>迭代语句</h3><p>（1）while 语句</p><pre><code class="hljs gauss"><span class="hljs-keyword">while</span> (condition)            statement</code></pre><p>（2）传统 for 语句</p><pre><code class="hljs mel"><span class="hljs-keyword">for</span> (initializar; <span class="hljs-keyword">condition</span>; <span class="hljs-keyword">expression</span>)        statement</code></pre><p>for 语句中定义的对象只在for循环体内可见。</p><p>（3）范围 for 语句</p><pre><code class="hljs less"><span class="hljs-selector-tag">for</span> (<span class="hljs-attribute">declaration </span>: expression)        <span class="hljs-selector-tag">statement</span></code></pre><p>（4）do while 语句</p><pre><code class="hljs lisp">do     statementwhile (<span class="hljs-name">condition</span>)</code></pre><h3 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h3><h4 id="break"><a href="#break" class="headerlink" title="break"></a><strong>break</strong></h4><p>break只能出现在迭代语句或者switch语句内部。仅限于终止离它最近的语句，然后从这些语句之后的第一条语句开始执行。</p><h4 id="continue"><a href="#continue" class="headerlink" title="continue"></a><strong>continue</strong></h4><p>continue语句终止最近的循环中的当前迭代并立即开始下一次迭代。</p><h4 id="goto"><a href="#goto" class="headerlink" title="goto"></a><strong>goto</strong></h4><p>goto的作用是从goto语句无条件跳转到同一函数内的另一条语句。</p><p>容易造成控制流混乱，应禁止使用。</p><h4 id="return"><a href="#return" class="headerlink" title="return"></a><strong>return</strong></h4><h3 id="try语句块和异常处理"><a href="#try语句块和异常处理" class="headerlink" title="try语句块和异常处理"></a>try语句块和异常处理</h3><p>C++中异常处理包括：throw表达式、try语句块。</p><p>try和catch，将一段可能抛出异常的语句序列括在花括号里构成try语句块。catch子句负责处理代码抛出的异常。</p><p>throw表达式语句，终止函数的执行。抛出一个异常，并把控制权转移到能处理该异常的最近的catch字句。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a><strong>函数</strong></h2><h3 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h3><h4 id="形参和实参："><a href="#形参和实参：" class="headerlink" title="形参和实参："></a>形参和实参：</h4><p>实参的类型必须与对应的形参类型匹配。</p><p>函数的调用规定实参数量应与形参数量一致。</p><h4 id="局部对象"><a href="#局部对象" class="headerlink" title="局部对象"></a>局部对象</h4><p>形参和参数体内部定义的变量统称为<strong>局部变量</strong>，它们对函数而言是”局部”的，仅在函数的作用域内可见，同时局部变量还会隐藏外层作用域中同名的其他变量。</p><p><strong>自动对象</strong>：只存在于块执行期间的对象。</p><p>局部静态对象：在程序的执行路径<strong>第一次经过对象定义语句时候进行初始化</strong>，并且直到程序终止才会被销毁。 </p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">count_calls</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> ctr = <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> ++ctr;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)    &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; count_calls() &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 程序输出12345678910</span>    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><p>函数的三要素：（返回类型、函数名、形参类型）。</p><p>函数可被声明多次，但只能被定义一次。</p><h4 id="分离式编译"><a href="#分离式编译" class="headerlink" title="分离式编译"></a>分离式编译</h4><p>分离式编译允许把程序分割到几个文件中去，每个文件独立编译。</p><p>编译-&gt;链接</p><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>当形参是引用类型，这时它对应的实参被引用传递或者函数被传引用调用。</p><p>当实参被拷贝给形参，这样的实参被值传递或者函数被传值调用。</p><p>（1）传值参数</p><p>（2）被引用传参</p><p>（3）const形参和实参</p><p>（4）数组形参</p><p> 为函数传递一个数组时，实际上传递的是指向数组首元素的指针。 </p><p>void print(const int*);<br>void pring(const int[]);<br>void print(const int[10]);<br>// 以上三个函数等价 </p><p> 数组引用实参：f(int (&amp;arr)[10]) </p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> *matrix[<span class="hljs-number">10</span>];   <span class="hljs-comment">// 10个指针构成的数组</span><span class="hljs-keyword">int</span> (*matrix)[<span class="hljs-number">10</span>]; <span class="hljs-comment">// 指向含有10个整数的数组的指针 </span></code></pre><p>（5）含有可变形参的数组</p><p>initializer_list</p><pre><code class="hljs reasonml"><span class="hljs-keyword">for</span> err<span class="hljs-constructor">_msg(<span class="hljs-params">initializer_list</span>&lt;<span class="hljs-params">string</span>&gt; <span class="hljs-params">li</span>)</span></code></pre><h4 id="返回类型和return语句"><a href="#返回类型和return语句" class="headerlink" title="返回类型和return语句"></a>返回类型和return语句</h4><p>2种：无返回值函数和右返回值函数。</p><pre><code class="hljs kotlin"><span class="hljs-keyword">return</span>;<span class="hljs-keyword">return</span> expression;</code></pre><p>函数完成后，它所占用的存储空间也会随着被释放掉。</p><p>返回局部对象的引用是错误的；返回局部对象的指针也是错误的。 </p><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>重载函数：同一作用域内的几个函数名字相同但形参列表不通，我们称之为重载函数。（overloaded）。</p><p><strong>不允许2个函数除了返回类型外其他所有的要素都相同。</strong></p><h4 id="重载与作用域"><a href="#重载与作用域" class="headerlink" title="重载与作用域"></a>重载与作用域</h4><p>如果在内存作用域中声明名字，它将隐藏外层作用域中声明的同名实体。</p><h3 id="特殊用途语言特性"><a href="#特殊用途语言特性" class="headerlink" title="特殊用途语言特性"></a>特殊用途语言特性</h3><p>（1）默认实参</p><p>函数调用时，实参按其位置解析，默认实参负责填补函数调用缺少的尾部实参。</p><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">string</span>::size_type sz;<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">screen</span><span class="hljs-params">(sz ht = <span class="hljs-number">24</span>, sz wid = <span class="hljs-number">80</span>, <span class="hljs-keyword">char</span> background = <span class="hljs-string">&#x27; &#x27;</span>)</span></span>;</code></pre><p>::: tip</p><p>当设计含有默认实参的函数时，需要合理设置形参的顺序。一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。</p><p>:::</p><p>（2）内联函数</p><p>使用关键词inline来声明内联函数。</p><p>内联用于<strong>优化规模较小，流程直接，频繁调用的函数</strong>。</p><p>（3）constexpr函数</p><p>constexpr函数是指能用于常量表达式的函数。</p><h3 id="函数匹配"><a href="#函数匹配" class="headerlink" title="函数匹配"></a>函数匹配</h3><p>Step1:确定候选函数和可选函数。</p><p>Step2:寻找最佳匹配。</p><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">useBigger</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s1, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s2, <span class="hljs-keyword">bool</span> pf(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;))</span></span>;等价于<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">useBigger</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s1, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s2, <span class="hljs-keyword">bool</span> (*pf)(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;))</span></span>;</code></pre><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类的基本思想是<strong>数据抽象和封装</strong>。</p><p>抽象是一种依赖于接口和实现分离的编程技术。</p><p>封装实现了类的接口和实现的分离。</p>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++core-guidelines</title>
    <link href="/2021/04/08/c++core-guidelines/"/>
    <url>/2021/04/08/c++core-guidelines/</url>
    
    <content type="html"><![CDATA[<h1 id="C-核心编程"><a href="#C-核心编程" class="headerlink" title="C++核心编程"></a>C++核心编程</h1><p>本阶段主要针对C++==面向对象==编程技术做详细讲解，探讨C++中的核心和精髓。</p><h2 id="1-内存分区模型"><a href="#1-内存分区模型" class="headerlink" title="1 内存分区模型"></a>1 内存分区模型</h2><p>C++程序在执行时，将内存大方向划分为<strong>4个区域</strong></p><ul><li>代码区：存放函数体的二进制代码，由操作系统进行管理的</li><li>全局区：存放全局变量和静态变量以及常量</li><li>栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等</li><li>堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收</li></ul><p><strong>内存四区意义：</strong></p><p>不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程</p><h3 id="1-1-程序运行前"><a href="#1-1-程序运行前" class="headerlink" title="1.1 程序运行前"></a>1.1 程序运行前</h3><p>​    在程序编译后，生成了exe可执行程序，<strong>未执行该程序前</strong>分为两个区域</p><p>​    <strong>代码区：</strong></p><p>​        存放 CPU 执行的机器指令</p><p>​        代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p><p>​        代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令</p><p>​    <strong>全局区：</strong></p><p>​        全局变量和静态变量存放在此.</p><p>​        全局区还包含了常量区, 字符串常量和其他常量也存放在此.</p><p>​        ==该区域的数据在程序结束后由操作系统释放==.</p><p><strong>示例：</strong></p><pre><code class="hljs c++"><span class="hljs-comment">//全局变量</span><span class="hljs-keyword">int</span> g_a = <span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> g_b = <span class="hljs-number">10</span>;<span class="hljs-comment">//全局常量</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> c_g_a = <span class="hljs-number">10</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> c_g_b = <span class="hljs-number">10</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//局部变量</span>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;    <span class="hljs-keyword">int</span> b = <span class="hljs-number">10</span>;    <span class="hljs-comment">//打印地址</span>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;局部变量a地址为： &quot;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)&amp;a &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;局部变量b地址为： &quot;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)&amp;b &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;全局变量g_a地址为： &quot;</span> &lt;&lt;  (<span class="hljs-keyword">int</span>)&amp;g_a &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;全局变量g_b地址为： &quot;</span> &lt;&lt;  (<span class="hljs-keyword">int</span>)&amp;g_b &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-comment">//静态变量</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> s_a = <span class="hljs-number">10</span>;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> s_b = <span class="hljs-number">10</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;静态变量s_a地址为： &quot;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)&amp;s_a &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;静态变量s_b地址为： &quot;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)&amp;s_b &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)&amp;<span class="hljs-string">&quot;hello world&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)&amp;<span class="hljs-string">&quot;hello world1&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;全局常量c_g_a地址为： &quot;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)&amp;c_g_a &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;全局常量c_g_b地址为： &quot;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)&amp;c_g_b &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> c_l_a = <span class="hljs-number">10</span>;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> c_l_b = <span class="hljs-number">10</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;局部常量c_l_a地址为： &quot;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)&amp;c_l_a &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;局部常量c_l_b地址为： &quot;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)&amp;c_l_b &lt;&lt; <span class="hljs-built_in">endl</span>;    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>打印结果：</p><p><img src="./1545017602518.png" alt="1545017602518"></p><p>总结：</p><ul><li>C++中在程序运行前分为全局区和代码区</li><li>代码区特点是共享和只读</li><li>全局区中存放全局变量、静态变量、常量</li><li>常量区中存放 const修饰的全局常量  和 字符串常量</li></ul><h3 id="1-2-程序运行后"><a href="#1-2-程序运行后" class="headerlink" title="1.2 程序运行后"></a>1.2 程序运行后</h3><p>​    <strong>栈区：</strong></p><p>​        由编译器自动分配释放, 存放函数的参数值,局部变量等</p><p>​        注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</p><p><strong>示例：</strong></p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> * <span class="hljs-title">func</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;    <span class="hljs-keyword">return</span> &amp;a;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> *p = func();    <span class="hljs-built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="hljs-built_in">endl</span>;    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>​    <strong>堆区：</strong></p><p>​        由程序员分配释放,若程序员不释放,程序结束时由操作系统回收</p><p>​        在C++中主要利用new在堆区开辟内存</p><p><strong>示例：</strong></p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">func</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span>* a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">10</span>);    <span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> *p = func();    <span class="hljs-built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="hljs-built_in">endl</span>;    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>总结：</strong></p><p>堆区数据由程序员管理开辟和释放</p><p>堆区数据利用new关键字进行开辟内存</p><h3 id="1-3-new操作符"><a href="#1-3-new操作符" class="headerlink" title="1.3 new操作符"></a>1.3 new操作符</h3><p>​    C++中利用==new==操作符在堆区开辟数据</p><p>​    堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 ==delete==</p><p>​    语法：<code> new 数据类型</code></p><p>​    利用new创建的数据，会返回该数据对应的类型的指针</p><p><strong>示例1： 基本语法</strong></p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">func</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span>* a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">10</span>);    <span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> *p = func();    <span class="hljs-built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-comment">//利用delete释放堆区数据</span>    <span class="hljs-keyword">delete</span> p;    <span class="hljs-comment">//cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问</span>    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>示例2：开辟数组</strong></p><pre><code class="hljs c++"><span class="hljs-comment">//堆区开辟数组</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span>* arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)    &#123;        arr[i] = i + <span class="hljs-number">100</span>;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)    &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-comment">//释放数组 delete 后加 []</span>    <span class="hljs-keyword">delete</span>[] arr;    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="2-引用"><a href="#2-引用" class="headerlink" title="2 引用"></a>2 引用</h2><h3 id="2-1-引用的基本使用"><a href="#2-1-引用的基本使用" class="headerlink" title="2.1 引用的基本使用"></a>2.1 引用的基本使用</h3><p>**作用： **给变量起别名</p><p><strong>语法：</strong> <code>数据类型 &amp;别名 = 原名</code></p><p><strong>示例：</strong></p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;    <span class="hljs-keyword">int</span> &amp;b = a;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">endl</span>;    b = <span class="hljs-number">100</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">endl</span>;    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="2-2-引用注意事项"><a href="#2-2-引用注意事项" class="headerlink" title="2.2 引用注意事项"></a>2.2 引用注意事项</h3><ul><li>引用必须初始化</li><li>引用在初始化后，不可以改变</li></ul><p>示例：</p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;    <span class="hljs-keyword">int</span> b = <span class="hljs-number">20</span>;    <span class="hljs-comment">//int &amp;c; //错误，引用必须初始化</span>    <span class="hljs-keyword">int</span> &amp;c = a; <span class="hljs-comment">//一旦初始化后，就不可以更改</span>    c = b; <span class="hljs-comment">//这是赋值操作，不是更改引用</span>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; <span class="hljs-built_in">endl</span>;    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="2-3-引用做函数参数"><a href="#2-3-引用做函数参数" class="headerlink" title="2.3 引用做函数参数"></a>2.3 引用做函数参数</h3><p><strong>作用：</strong>函数传参时，可以利用引用的技术让形参修饰实参</p><p><strong>优点：</strong>可以简化指针修改实参</p><p><strong>示例：</strong></p><pre><code class="hljs C++"><span class="hljs-comment">//1. 值传递</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mySwap01</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;    <span class="hljs-keyword">int</span> temp = a;    a = b;    b = temp;&#125;<span class="hljs-comment">//2. 地址传递</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mySwap02</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* a, <span class="hljs-keyword">int</span>* b)</span> </span>&#123;    <span class="hljs-keyword">int</span> temp = *a;    *a = *b;    *b = temp;&#125;<span class="hljs-comment">//3. 引用传递</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mySwap03</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; a, <span class="hljs-keyword">int</span>&amp; b)</span> </span>&#123;    <span class="hljs-keyword">int</span> temp = a;    a = b;    b = temp;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;    <span class="hljs-keyword">int</span> b = <span class="hljs-number">20</span>;    mySwap01(a, b);    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">endl</span>;    mySwap02(&amp;a, &amp;b);    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">endl</span>;    mySwap03(a, b);    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">endl</span>;    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><blockquote><p>总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单</p></blockquote><h3 id="2-4-引用做函数返回值"><a href="#2-4-引用做函数返回值" class="headerlink" title="2.4 引用做函数返回值"></a>2.4 引用做函数返回值</h3><p>作用：引用是可以作为函数的返回值存在的</p><p>注意：<strong>不要返回局部变量引用</strong></p><p>用法：函数调用作为左值</p><p><strong>示例：</strong></p><pre><code class="hljs C++"><span class="hljs-comment">//返回局部变量引用</span><span class="hljs-function"><span class="hljs-keyword">int</span>&amp; <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>; <span class="hljs-comment">//局部变量</span>    <span class="hljs-keyword">return</span> a;&#125;<span class="hljs-comment">//返回静态变量引用</span><span class="hljs-function"><span class="hljs-keyword">int</span>&amp; <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">20</span>;    <span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//不能返回局部变量的引用</span>    <span class="hljs-keyword">int</span>&amp; ref = test01();    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-comment">//如果函数做左值，那么必须返回引用</span>    <span class="hljs-keyword">int</span>&amp; ref2 = test02();    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; <span class="hljs-built_in">endl</span>;    test02() = <span class="hljs-number">1000</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; <span class="hljs-built_in">endl</span>;    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>​    </p><h3 id="2-5-引用的本质"><a href="#2-5-引用的本质" class="headerlink" title="2.5 引用的本质"></a>2.5 引用的本质</h3><p>本质：<strong>引用的本质在c++内部实现是一个指针常量.</strong></p><p>讲解示例：</p><pre><code class="hljs C++"><span class="hljs-comment">//发现是引用，转换为 int* const ref = &amp;a;</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; ref)</span></span>&#123;    ref = <span class="hljs-number">100</span>; <span class="hljs-comment">// ref是引用，转换为*ref = 100</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;    <span class="hljs-comment">//自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改</span>    <span class="hljs-keyword">int</span>&amp; ref = a;     ref = <span class="hljs-number">20</span>; <span class="hljs-comment">//内部发现ref是引用，自动帮我们转换为: *ref = 20;</span>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;ref:&quot;</span> &lt;&lt; ref &lt;&lt; <span class="hljs-built_in">endl</span>;    func(a);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</p><h3 id="2-6-常量引用"><a href="#2-6-常量引用" class="headerlink" title="2.6 常量引用"></a>2.6 常量引用</h3><p><strong>作用：</strong>常量引用主要用来修饰形参，防止误操作</p><p>在函数形参列表中，可以加==const修饰形参==，防止形参改变实参</p><p><strong>示例：</strong></p><pre><code class="hljs C++"><span class="hljs-comment">//引用使用的场景，通常用来修饰形参</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showValue</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; v)</span> </span>&#123;    <span class="hljs-comment">//v += 10;</span>    <span class="hljs-built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//int&amp; ref = 10;  引用本身需要一个合法的内存空间，因此这行错误</span>    <span class="hljs-comment">//加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp;</span>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; ref = <span class="hljs-number">10</span>;    <span class="hljs-comment">//ref = 100;  //加入const后不可以修改变量</span>    <span class="hljs-built_in">cout</span> &lt;&lt; ref &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-comment">//函数中利用常量引用防止误操作修改实参</span>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;    showValue(a);    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="3-函数提高"><a href="#3-函数提高" class="headerlink" title="3 函数提高"></a>3 函数提高</h2><h3 id="3-1-函数默认参数"><a href="#3-1-函数默认参数" class="headerlink" title="3.1 函数默认参数"></a>3.1 函数默认参数</h3><p>在C++中，函数的形参列表中的形参是可以有默认值的。</p><p>语法：<code> 返回值类型  函数名 （参数= 默认值）&#123;&#125;</code></p><p><strong>示例：</strong></p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b = <span class="hljs-number">10</span>, <span class="hljs-keyword">int</span> c = <span class="hljs-number">10</span>)</span> </span>&#123;    <span class="hljs-keyword">return</span> a + b + c;&#125;<span class="hljs-comment">//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值</span><span class="hljs-comment">//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>, <span class="hljs-keyword">int</span> b = <span class="hljs-number">10</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;    <span class="hljs-keyword">return</span> a + b;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;ret = &quot;</span> &lt;&lt; func(<span class="hljs-number">20</span>, <span class="hljs-number">20</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;ret = &quot;</span> &lt;&lt; func(<span class="hljs-number">100</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="3-2-函数占位参数"><a href="#3-2-函数占位参数" class="headerlink" title="3.2 函数占位参数"></a>3.2 函数占位参数</h3><p>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p><p><strong>语法：</strong> <code>返回值类型 函数名 (数据类型)&#123;&#125;</code></p><p>在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术</p><p><strong>示例：</strong></p><pre><code class="hljs C++"><span class="hljs-comment">//函数占位参数 ，占位参数也可以有默认参数</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span>)</span> </span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;this is func&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    func(<span class="hljs-number">10</span>,<span class="hljs-number">10</span>); <span class="hljs-comment">//占位参数必须填补</span>    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="3-3-函数重载"><a href="#3-3-函数重载" class="headerlink" title="3.3 函数重载"></a>3.3 函数重载</h3><h4 id="3-3-1-函数重载概述"><a href="#3-3-1-函数重载概述" class="headerlink" title="3.3.1 函数重载概述"></a>3.3.1 函数重载概述</h4><p><strong>作用：</strong>函数名可以相同，提高复用性</p><p><strong>函数重载满足条件：</strong></p><ul><li>同一个作用域下</li><li>函数名称相同</li><li>函数参数<strong>类型不同</strong>  或者 <strong>个数不同</strong> 或者 <strong>顺序不同</strong></li></ul><p><strong>注意:</strong>  函数的返回值不可以作为函数重载的条件</p><p><strong>示例：</strong></p><pre><code class="hljs C++"><span class="hljs-comment">//函数重载需要函数都在同一个作用域下</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;func 的调用！&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;func (int a) 的调用！&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">double</span> a)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;func (double a)的调用！&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a ,<span class="hljs-keyword">double</span> b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;func (int a ,double b) 的调用！&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">double</span> a ,<span class="hljs-keyword">int</span> b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;func (double a ,int b)的调用！&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-comment">//函数返回值不可以作为函数重载条件</span><span class="hljs-comment">//int func(double a, int b)</span><span class="hljs-comment">//&#123;</span><span class="hljs-comment">//    cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;</span><span class="hljs-comment">//&#125;</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    func();    func(<span class="hljs-number">10</span>);    func(<span class="hljs-number">3.14</span>);    func(<span class="hljs-number">10</span>,<span class="hljs-number">3.14</span>);    func(<span class="hljs-number">3.14</span> , <span class="hljs-number">10</span>);    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="3-3-2-函数重载注意事项"><a href="#3-3-2-函数重载注意事项" class="headerlink" title="3.3.2 函数重载注意事项"></a>3.3.2 函数重载注意事项</h4><ul><li>引用作为重载条件</li><li>函数重载碰到函数默认参数</li></ul><p><strong>示例：</strong></p><pre><code class="hljs C++"><span class="hljs-comment">//函数重载注意事项</span><span class="hljs-comment">//1、引用作为重载条件</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;a)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;func (int &amp;a) 调用 &quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;a)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;func (const int &amp;a) 调用 &quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-comment">//2、函数重载碰到函数默认参数</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b = <span class="hljs-number">10</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;func2(int a, int b = 10) 调用&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;func2(int a) 调用&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;    func(a); <span class="hljs-comment">//调用无const</span>    func(<span class="hljs-number">10</span>);<span class="hljs-comment">//调用有const</span>    <span class="hljs-comment">//func2(10); //碰到默认参数产生歧义，需要避免</span>    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="4-类和对象"><a href="#4-类和对象" class="headerlink" title="4 类和对象"></a><strong>4</strong> 类和对象</h2><p>C++面向对象的三大特性为：==封装、继承、多态==</p><p>C++认为==万事万物都皆为对象==，对象上有其属性和行为</p><p><strong>例如：</strong></p><p>​    人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌…</p><p>​    车也可以作为对象，属性有轮胎、方向盘、车灯…,行为有载人、放音乐、放空调…</p><p>​    具有相同性质的==对象==，我们可以抽象称为==类==，人属于人类，车属于车类</p><h3 id="4-1-封装"><a href="#4-1-封装" class="headerlink" title="4.1 封装"></a>4.1 封装</h3><h4 id="4-1-1-封装的意义"><a href="#4-1-1-封装的意义" class="headerlink" title="4.1.1  封装的意义"></a>4.1.1  封装的意义</h4><p>封装是C++面向对象三大特性之一</p><p>封装的意义：</p><ul><li>将属性和行为作为一个整体，表现生活中的事物</li><li>将属性和行为加以权限控制</li></ul><p><strong>封装意义一：</strong></p><p>​    在设计类的时候，属性和行为写在一起，表现事物</p><p><strong>语法：</strong> <code>class 类名&#123;   访问权限： 属性  / 行为  &#125;;</code></p><p><strong>示例1：</strong>设计一个圆类，求圆的周长</p><p><strong>示例代码：</strong></p><pre><code class="hljs C++"><span class="hljs-comment">//圆周率</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> PI = <span class="hljs-number">3.14</span>;<span class="hljs-comment">//1、封装的意义</span><span class="hljs-comment">//将属性和行为作为一个整体，用来表现生活中的事物</span><span class="hljs-comment">//封装一个圆类，求圆的周长</span><span class="hljs-comment">//class代表设计一个类，后面跟着的是类名</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:  <span class="hljs-comment">//访问权限  公共的权限</span>    <span class="hljs-comment">//属性</span>    <span class="hljs-keyword">int</span> m_r;<span class="hljs-comment">//半径</span>    <span class="hljs-comment">//行为</span>    <span class="hljs-comment">//获取到圆的周长</span>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">calculateZC</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-comment">//2 * pi  * r</span>        <span class="hljs-comment">//获取圆的周长</span>        <span class="hljs-keyword">return</span>  <span class="hljs-number">2</span> * PI * m_r;    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//通过圆类，创建圆的对象</span>    <span class="hljs-comment">// c1就是一个具体的圆</span>    Circle c1;    c1.m_r = <span class="hljs-number">10</span>; <span class="hljs-comment">//给圆对象的半径 进行赋值操作</span>    <span class="hljs-comment">//2 * pi * 10 = = 62.8</span>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;圆的周长为： &quot;</span> &lt;&lt; c1.calculateZC() &lt;&lt; <span class="hljs-built_in">endl</span>;    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>示例2：</strong>设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号</p><p><strong>示例2代码：</strong></p><pre><code class="hljs C++"><span class="hljs-comment">//学生类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(<span class="hljs-built_in">string</span> name)</span> </span>&#123;        m_name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setID</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;        m_id = id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showStudent</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;name:&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="hljs-string">&quot; ID:&quot;</span> &lt;&lt; m_id &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">string</span> m_name;    <span class="hljs-keyword">int</span> m_id;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    Student stu;    stu.setName(<span class="hljs-string">&quot;德玛西亚&quot;</span>);    stu.setID(<span class="hljs-number">250</span>);    stu.showStudent();    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>封装意义二：</strong></p><p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p><p>访问权限有三种：</p><ol><li>public        公共权限  </li><li>protected 保护权限</li><li>private      私有权限</li></ol><p><strong>示例：</strong></p><pre><code class="hljs C++"><span class="hljs-comment">//三种权限</span><span class="hljs-comment">//公共权限  public     类内可以访问  类外可以访问</span><span class="hljs-comment">//保护权限  protected  类内可以访问  类外不可以访问</span><span class="hljs-comment">//私有权限  private    类内可以访问  类外不可以访问</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-comment">//姓名  公共权限</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">string</span> m_Name;    <span class="hljs-comment">//汽车  保护权限</span><span class="hljs-keyword">protected</span>:    <span class="hljs-built_in">string</span> m_Car;    <span class="hljs-comment">//银行卡密码  私有权限</span><span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> m_Password;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        m_Name = <span class="hljs-string">&quot;张三&quot;</span>;        m_Car = <span class="hljs-string">&quot;拖拉机&quot;</span>;        m_Password = <span class="hljs-number">123456</span>;    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    Person p;    p.m_Name = <span class="hljs-string">&quot;李四&quot;</span>;    <span class="hljs-comment">//p.m_Car = &quot;奔驰&quot;;  //保护权限类外访问不到</span>    <span class="hljs-comment">//p.m_Password = 123; //私有权限类外访问不到</span>    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="4-1-2-struct和class区别"><a href="#4-1-2-struct和class区别" class="headerlink" title="4.1.2 struct和class区别"></a>4.1.2 struct和class区别</h4><p>在C++中 struct和class唯一的<strong>区别</strong>就在于 <strong>默认的访问权限不同</strong></p><p>区别：</p><ul><li>struct 默认权限为公共</li><li>class   默认权限为私有</li></ul><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C1</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span>  m_A; <span class="hljs-comment">//默认是私有权限</span>&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">C2</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> m_A;  <span class="hljs-comment">//默认是公共权限</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    C1 c1;    c1.m_A = <span class="hljs-number">10</span>; <span class="hljs-comment">//错误，访问权限是私有</span>    C2 c2;    c2.m_A = <span class="hljs-number">10</span>; <span class="hljs-comment">//正确，访问权限是公共</span>    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="4-1-3-成员属性设置为私有"><a href="#4-1-3-成员属性设置为私有" class="headerlink" title="4.1.3 成员属性设置为私有"></a>4.1.3 成员属性设置为私有</h4><p><strong>优点1：</strong>将所有成员属性设置为私有，可以自己控制读写权限</p><p><strong>优点2：</strong>对于写权限，我们可以检测数据的有效性</p><p><strong>示例：</strong></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-comment">//姓名设置可读可写</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(<span class="hljs-built_in">string</span> name)</span> </span>&#123;        m_Name = name;    &#125;    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> m_Name;    &#125;    <span class="hljs-comment">//获取年龄 </span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> m_Age;    &#125;    <span class="hljs-comment">//设置年龄</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;        <span class="hljs-keyword">if</span> (age &lt; <span class="hljs-number">0</span> || age &gt; <span class="hljs-number">150</span>) &#123;            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;你个老妖精!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;            <span class="hljs-keyword">return</span>;        &#125;        m_Age = age;    &#125;    <span class="hljs-comment">//情人设置为只写</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setLover</span><span class="hljs-params">(<span class="hljs-built_in">string</span> lover)</span> </span>&#123;        m_Lover = lover;    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-built_in">string</span> m_Name; <span class="hljs-comment">//可读可写  姓名</span>    <span class="hljs-keyword">int</span> m_Age; <span class="hljs-comment">//只读  年龄</span>    <span class="hljs-built_in">string</span> m_Lover; <span class="hljs-comment">//只写  情人</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    Person p;    <span class="hljs-comment">//姓名设置</span>    p.setName(<span class="hljs-string">&quot;张三&quot;</span>);    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;姓名： &quot;</span> &lt;&lt; p.getName() &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-comment">//年龄设置</span>    p.setAge(<span class="hljs-number">50</span>);    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;年龄： &quot;</span> &lt;&lt; p.getAge() &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-comment">//情人设置</span>    p.setLover(<span class="hljs-string">&quot;苍井&quot;</span>);    <span class="hljs-comment">//cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl;  //只写属性，不可以读取</span>    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>练习案例1：设计立方体类</strong></p><p>设计立方体类(Cube)</p><p>求出立方体的面积和体积</p><p>分别用全局函数和成员函数判断两个立方体是否相等。</p><p><img src="./1545533548532.png" alt="1545533548532"></p><p><strong>练习案例2：点和圆的关系</strong></p><p>设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系。</p><p><img src="./1545533829184.png" alt="1545533829184"></p><h3 id="4-2-对象的初始化和清理"><a href="#4-2-对象的初始化和清理" class="headerlink" title="4.2 对象的初始化和清理"></a>4.2 对象的初始化和清理</h3><ul><li>生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全</li><li>C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。</li></ul><h4 id="4-2-1-构造函数和析构函数"><a href="#4-2-1-构造函数和析构函数" class="headerlink" title="4.2.1 构造函数和析构函数"></a>4.2.1 构造函数和析构函数</h4><p>对象的<strong>初始化和清理</strong>也是两个非常重要的安全问题</p><p>​    一个对象或者变量没有初始状态，对其使用后果是未知</p><p>​    同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p><p>c++利用了<strong>构造函数</strong>和<strong>析构函数</strong>解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p><p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果<strong>我们不提供构造和析构，编译器会提供</strong></p><p><strong>编译器提供的构造函数和析构函数是空实现。</strong></p><ul><li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</li><li>析构函数：主要作用在于对象<strong>销毁前</strong>系统自动调用，执行一些清理工作。</li></ul><p><strong>构造函数语法：</strong><code>类名()&#123;&#125;</code></p><ol><li>构造函数，没有返回值也不写void</li><li>函数名称与类名相同</li><li>构造函数可以有参数，因此可以发生重载</li><li>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次</li></ol><p><strong>析构函数语法：</strong> <code>~类名()&#123;&#125;</code></p><ol><li>析构函数，没有返回值也不写void</li><li>函数名称与类名相同,在名称前加上符号  ~</li><li>析构函数不可以有参数，因此不可以发生重载</li><li>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次</li></ol><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-comment">//构造函数</span>    Person()    &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Person的构造函数调用&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-comment">//析构函数</span>    ~Person()    &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    Person p;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    test01();    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="4-2-2-构造函数的分类及调用"><a href="#4-2-2-构造函数的分类及调用" class="headerlink" title="4.2.2 构造函数的分类及调用"></a>4.2.2 构造函数的分类及调用</h4><p>两种分类方式：</p><p>​    按参数分为： 有参构造和无参构造</p><p>​    按类型分为： 普通构造和拷贝构造</p><p>三种调用方式：</p><p>​    括号法</p><p>​    显示法</p><p>​    隐式转换法</p><p><strong>示例：</strong></p><pre><code class="hljs C++"><span class="hljs-comment">//1、构造函数分类</span><span class="hljs-comment">// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数</span><span class="hljs-comment">// 按照类型分类分为 普通构造和拷贝构造</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-comment">//无参（默认）构造函数</span>    Person() &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;无参构造函数!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-comment">//有参构造函数</span>    Person(<span class="hljs-keyword">int</span> a) &#123;        age = a;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;有参构造函数!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-comment">//拷贝构造函数</span>    Person(<span class="hljs-keyword">const</span> Person&amp; p) &#123;        age = p.age;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-comment">//析构函数</span>    ~Person() &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;析构函数!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">int</span> age;&#125;;<span class="hljs-comment">//2、构造函数的调用</span><span class="hljs-comment">//调用无参构造函数</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;    Person p; <span class="hljs-comment">//调用无参构造函数</span>&#125;<span class="hljs-comment">//调用有参的构造函数</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//2.1  括号法，常用</span>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;    <span class="hljs-comment">//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</span>    <span class="hljs-comment">//Person p2();</span>    <span class="hljs-comment">//2.2 显式法</span>    Person p2 = Person(<span class="hljs-number">10</span>);     Person p3 = Person(p2);    <span class="hljs-comment">//Person(10)单独写就是匿名对象  当前行结束之后，马上析构</span>    <span class="hljs-comment">//2.3 隐式转换法</span>    Person p4 = <span class="hljs-number">10</span>; <span class="hljs-comment">// Person p4 = Person(10); </span>    Person p5 = p4; <span class="hljs-comment">// Person p5 = Person(p4); </span>    <span class="hljs-comment">//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明</span>    <span class="hljs-comment">//Person p5(p4);</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    test01();    <span class="hljs-comment">//test02();</span>    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="4-2-3-拷贝构造函数调用时机"><a href="#4-2-3-拷贝构造函数调用时机" class="headerlink" title="4.2.3 拷贝构造函数调用时机"></a>4.2.3 拷贝构造函数调用时机</h4><p>C++中拷贝构造函数调用时机通常有三种情况</p><ul><li>使用一个已经创建完毕的对象来初始化一个新对象</li><li>值传递的方式给函数参数传值</li><li>以值方式返回局部对象</li></ul><p><strong>示例：</strong></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><span class="hljs-keyword">public</span>:    Person() &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;无参构造函数!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        mAge = <span class="hljs-number">0</span>;    &#125;    Person(<span class="hljs-keyword">int</span> age) &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;有参构造函数!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        mAge = age;    &#125;    Person(<span class="hljs-keyword">const</span> Person&amp; p) &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        mAge = p.mAge;    &#125;    <span class="hljs-comment">//析构函数在释放内存之前调用</span>    ~Person() &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;析构函数!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">int</span> mAge;&#125;;<span class="hljs-comment">//1. 使用一个已经创建完毕的对象来初始化一个新对象</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-function">Person <span class="hljs-title">man</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>; <span class="hljs-comment">//p对象已经创建完毕</span>    <span class="hljs-function">Person <span class="hljs-title">newman</span><span class="hljs-params">(man)</span></span>; <span class="hljs-comment">//调用拷贝构造函数</span>    Person newman2 = man; <span class="hljs-comment">//拷贝构造</span>    <span class="hljs-comment">//Person newman3;</span>    <span class="hljs-comment">//newman3 = man; //不是调用拷贝构造函数，赋值操作</span>&#125;<span class="hljs-comment">//2. 值传递的方式给函数参数传值</span><span class="hljs-comment">//相当于Person p1 = p;</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doWork</span><span class="hljs-params">(Person p1)</span> </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;    Person p; <span class="hljs-comment">//无参构造函数</span>    doWork(p);&#125;<span class="hljs-comment">//3. 以值方式返回局部对象</span><span class="hljs-function">Person <span class="hljs-title">doWork2</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    Person p1;    <span class="hljs-built_in">cout</span> &lt;&lt; (<span class="hljs-keyword">int</span> *)&amp;p1 &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> p1;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    Person p = doWork2();    <span class="hljs-built_in">cout</span> &lt;&lt; (<span class="hljs-keyword">int</span> *)&amp;p &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//test01();</span>    <span class="hljs-comment">//test02();</span>    test03();    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="4-2-4-构造函数调用规则"><a href="#4-2-4-构造函数调用规则" class="headerlink" title="4.2.4 构造函数调用规则"></a>4.2.4 构造函数调用规则</h4><p>默认情况下，c++编译器至少给一个类添加3个函数</p><p>1．默认构造函数(无参，函数体为空)</p><p>2．默认析构函数(无参，函数体为空)</p><p>3．默认拷贝构造函数，对属性进行值拷贝</p><p>构造函数调用规则如下：</p><ul><li>如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造</li></ul><ul><li>如果用户定义拷贝构造函数，c++不会再提供其他构造函数</li></ul><p>示例：</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-comment">//无参（默认）构造函数</span>    Person() &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;无参构造函数!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-comment">//有参构造函数</span>    Person(<span class="hljs-keyword">int</span> a) &#123;        age = a;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;有参构造函数!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-comment">//拷贝构造函数</span>    Person(<span class="hljs-keyword">const</span> Person&amp; p) &#123;        age = p.age;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-comment">//析构函数</span>    ~Person() &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;析构函数!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">int</span> age;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">18</span>)</span></span>;    <span class="hljs-comment">//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作</span>    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(p1)</span></span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;p2的年龄为： &quot;</span> &lt;&lt; p2.age &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造</span>    Person p1; <span class="hljs-comment">//此时如果用户自己没有提供默认构造，会出错</span>    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">//用户提供的有参</span>    <span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(p2)</span></span>; <span class="hljs-comment">//此时如果用户没有提供拷贝构造，编译器会提供</span>    <span class="hljs-comment">//如果用户提供拷贝构造，编译器不会提供其他构造函数</span>    Person p4; <span class="hljs-comment">//此时如果用户自己没有提供默认构造，会出错</span>    <span class="hljs-function">Person <span class="hljs-title">p5</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">//此时如果用户自己没有提供有参，会出错</span>    <span class="hljs-function">Person <span class="hljs-title">p6</span><span class="hljs-params">(p5)</span></span>; <span class="hljs-comment">//用户自己提供拷贝构造</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    test01();    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="4-2-5-深拷贝与浅拷贝"><a href="#4-2-5-深拷贝与浅拷贝" class="headerlink" title="4.2.5 深拷贝与浅拷贝"></a>4.2.5 深拷贝与浅拷贝</h4><p>深浅拷贝是面试经典问题，也是常见的一个坑</p><p>浅拷贝：简单的赋值拷贝操作</p><p>深拷贝：在堆区重新申请空间，进行拷贝操作</p><p><strong>示例：</strong></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-comment">//无参（默认）构造函数</span>    Person() &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;无参构造函数!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-comment">//有参构造函数</span>    Person(<span class="hljs-keyword">int</span> age ,<span class="hljs-keyword">int</span> <span class="hljs-built_in">height</span>) &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;有参构造函数!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        m_age = age;        m_height = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-built_in">height</span>);    &#125;    <span class="hljs-comment">//拷贝构造函数  </span>    Person(<span class="hljs-keyword">const</span> Person&amp; p) &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        <span class="hljs-comment">//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题</span>        m_age = p.m_age;        m_height = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(*p.m_height);    &#125;    <span class="hljs-comment">//析构函数</span>    ~Person() &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;析构函数!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        <span class="hljs-keyword">if</span> (m_height != <span class="hljs-literal">NULL</span>)        &#123;            <span class="hljs-keyword">delete</span> m_height;        &#125;    &#125;<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">int</span> m_age;    <span class="hljs-keyword">int</span>* m_height;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">18</span>, <span class="hljs-number">180</span>)</span></span>;    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(p1)</span></span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;p1的年龄： &quot;</span> &lt;&lt; p1.m_age &lt;&lt; <span class="hljs-string">&quot; 身高： &quot;</span> &lt;&lt; *p1.m_height &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;p2的年龄： &quot;</span> &lt;&lt; p2.m_age &lt;&lt; <span class="hljs-string">&quot; 身高： &quot;</span> &lt;&lt; *p2.m_height &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    test01();    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><blockquote><p>总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p></blockquote><h4 id="4-2-6-初始化列表"><a href="#4-2-6-初始化列表" class="headerlink" title="4.2.6 初始化列表"></a>4.2.6 初始化列表</h4><p><strong>作用：</strong></p><p>C++提供了初始化列表语法，用来初始化属性</p><p><strong>语法：</strong><code>构造函数()：属性1(值1),属性2（值2）... &#123;&#125;</code></p><p><strong>示例：</strong></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-comment">////传统方式初始化</span>    <span class="hljs-comment">//Person(int a, int b, int c) &#123;</span>    <span class="hljs-comment">//    m_A = a;</span>    <span class="hljs-comment">//    m_B = b;</span>    <span class="hljs-comment">//    m_C = c;</span>    <span class="hljs-comment">//&#125;</span>    <span class="hljs-comment">//初始化列表方式初始化</span>    Person(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c) :m_A(a), m_B(b), m_C(c) &#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintPerson</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;mA:&quot;</span> &lt;&lt; m_A &lt;&lt; <span class="hljs-built_in">endl</span>;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;mB:&quot;</span> &lt;&lt; m_B &lt;&lt; <span class="hljs-built_in">endl</span>;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;mC:&quot;</span> &lt;&lt; m_C &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> m_A;    <span class="hljs-keyword">int</span> m_B;    <span class="hljs-keyword">int</span> m_C;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-function">Person <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span></span>;    p.PrintPerson();    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="4-2-7-类对象作为类成员"><a href="#4-2-7-类对象作为类成员" class="headerlink" title="4.2.7 类对象作为类成员"></a>4.2.7 类对象作为类成员</h4><p>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员</p><p>例如：</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span>&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><span class="hljs-class">&#123;</span>    A a；&#125;</code></pre><p>B类中有对象A作为成员，A为对象成员</p><p>那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？</p><p><strong>示例：</strong></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    Phone(<span class="hljs-built_in">string</span> name)    &#123;        m_PhoneName = name;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Phone构造&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    ~Phone()    &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Phone析构&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-built_in">string</span> m_PhoneName;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-comment">//初始化列表可以告诉编译器调用哪一个构造函数</span>    Person(<span class="hljs-built_in">string</span> name, <span class="hljs-built_in">string</span> pName) :m_Name(name), m_Phone(pName)    &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Person构造&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    ~Person()    &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Person析构&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">playGame</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; m_Name &lt;&lt; <span class="hljs-string">&quot; 使用&quot;</span> &lt;&lt; m_Phone.m_PhoneName &lt;&lt; <span class="hljs-string">&quot; 牌手机! &quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-built_in">string</span> m_Name;    Phone m_Phone;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//当类中成员是其他类对象时，我们称该成员为 对象成员</span>    <span class="hljs-comment">//构造的顺序是 ：先调用对象成员的构造，再调用本类构造</span>    <span class="hljs-comment">//析构顺序与构造相反</span>    <span class="hljs-function">Person <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;张三&quot;</span> , <span class="hljs-string">&quot;苹果X&quot;</span>)</span></span>;    p.playGame();&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    test01();    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="4-2-8-静态成员"><a href="#4-2-8-静态成员" class="headerlink" title="4.2.8 静态成员"></a>4.2.8 静态成员</h4><p>静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员</p><p>静态成员分为：</p><ul><li>静态成员变量<ul><li>所有对象共享同一份数据</li><li>在编译阶段分配内存</li><li>类内声明，类外初始化</li></ul></li><li>静态成员函数<ul><li>所有对象共享同一个函数</li><li>静态成员函数只能访问静态成员变量</li></ul></li></ul><p><strong>示例1 ：</strong>静态成员变量</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> m_A; <span class="hljs-comment">//静态成员变量</span>    <span class="hljs-comment">//静态成员变量特点：</span>    <span class="hljs-comment">//1 在编译阶段分配内存</span>    <span class="hljs-comment">//2 类内声明，类外初始化</span>    <span class="hljs-comment">//3 所有对象共享同一份数据</span><span class="hljs-keyword">private</span>:    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> m_B; <span class="hljs-comment">//静态成员变量也是有访问权限的</span>&#125;;<span class="hljs-keyword">int</span> Person::m_A = <span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> Person::m_B = <span class="hljs-number">10</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//静态成员变量两种访问方式</span>    <span class="hljs-comment">//1、通过对象</span>    Person p1;    p1.m_A = <span class="hljs-number">100</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; <span class="hljs-built_in">endl</span>;    Person p2;    p2.m_A = <span class="hljs-number">200</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">//共享同一份数据</span>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;p2.m_A = &quot;</span> &lt;&lt; p2.m_A &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-comment">//2、通过类名</span>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;m_A = &quot;</span> &lt;&lt; Person::m_A &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-comment">//cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    test01();    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>示例2：</strong>静态成员函数</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-comment">//静态成员函数特点：</span>    <span class="hljs-comment">//1 程序共享一个函数</span>    <span class="hljs-comment">//2 静态成员函数只能访问静态成员变量</span>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;func调用&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        m_A = <span class="hljs-number">100</span>;        <span class="hljs-comment">//m_B = 100; //错误，不可以访问非静态成员变量</span>    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> m_A; <span class="hljs-comment">//静态成员变量</span>    <span class="hljs-keyword">int</span> m_B; <span class="hljs-comment">// </span><span class="hljs-keyword">private</span>:    <span class="hljs-comment">//静态成员函数也是有访问权限的</span>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;func2调用&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;;<span class="hljs-keyword">int</span> Person::m_A = <span class="hljs-number">10</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//静态成员变量两种访问方式</span>    <span class="hljs-comment">//1、通过对象</span>    Person p1;    p1.func();    <span class="hljs-comment">//2、通过类名</span>    Person::func();    <span class="hljs-comment">//Person::func2(); //私有权限访问不到</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    test01();    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="4-3-C-对象模型和this指针"><a href="#4-3-C-对象模型和this指针" class="headerlink" title="4.3 C++对象模型和this指针"></a>4.3 C++对象模型和this指针</h3><h4 id="4-3-1-成员变量和成员函数分开存储"><a href="#4-3-1-成员变量和成员函数分开存储" class="headerlink" title="4.3.1 成员变量和成员函数分开存储"></a>4.3.1 成员变量和成员函数分开存储</h4><p>在C++中，类内的成员变量和成员函数分开存储</p><p>只有非静态成员变量才属于类的对象上</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><span class="hljs-keyword">public</span>:    Person() &#123;        mA = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">//非静态成员变量占对象空间</span>    <span class="hljs-keyword">int</span> mA;    <span class="hljs-comment">//静态成员变量不占对象空间</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> mB;     <span class="hljs-comment">//函数也不占对象空间，所有函数共享一个函数实例</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;mA:&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;mA &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-comment">//静态成员函数也不占对象空间</span>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sfunc</span><span class="hljs-params">()</span> </span>&#123;    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(Person) &lt;&lt; <span class="hljs-built_in">endl</span>;    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="4-3-2-this指针概念"><a href="#4-3-2-this指针概念" class="headerlink" title="4.3.2 this指针概念"></a>4.3.2 this指针概念</h4><p>通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的</p><p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p><p>那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p><p>c++通过提供特殊的对象指针，this指针，解决上述问题。<strong>this指针指向被调用的成员函数所属的对象</strong></p><p>this指针是隐含每一个非静态成员函数内的一种指针</p><p>this指针不需要定义，直接使用即可</p><p>this指针的用途：</p><ul><li>当形参和成员变量同名时，可用this指针来区分</li><li>在类的非静态成员函数中返回对象本身，可使用return *this</li></ul><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    Person(<span class="hljs-keyword">int</span> age)    &#123;        <span class="hljs-comment">//1、当形参和成员变量同名时，可用this指针来区分</span>        <span class="hljs-keyword">this</span>-&gt;age = age;    &#125;    <span class="hljs-function">Person&amp; <span class="hljs-title">PersonAddPerson</span><span class="hljs-params">(Person p)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">this</span>-&gt;age += p.age;        <span class="hljs-comment">//返回对象本身</span>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-keyword">int</span> age;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;p1.age = &quot;</span> &lt;&lt; p1.age &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;    p2.PersonAddPerson(p1).PersonAddPerson(p1).PersonAddPerson(p1);    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;p2.age = &quot;</span> &lt;&lt; p2.age &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    test01();    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="4-3-3-空指针访问成员函数"><a href="#4-3-3-空指针访问成员函数" class="headerlink" title="4.3.3 空指针访问成员函数"></a>4.3.3 空指针访问成员函数</h4><p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p><p>如果用到this指针，需要加以判断保证代码的健壮性</p><p><strong>示例：</strong></p><pre><code class="hljs C++"><span class="hljs-comment">//空指针访问成员函数</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ShowClassName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;我是Person类!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ShowPerson</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == <span class="hljs-literal">NULL</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-built_in">cout</span> &lt;&lt; mAge &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">int</span> mAge;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    Person * p = <span class="hljs-literal">NULL</span>;    p-&gt;ShowClassName(); <span class="hljs-comment">//空指针，可以调用成员函数</span>    p-&gt;ShowPerson();  <span class="hljs-comment">//但是如果成员函数中用到了this指针，就不可以了</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    test01();    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="4-3-4-const修饰成员函数"><a href="#4-3-4-const修饰成员函数" class="headerlink" title="4.3.4 const修饰成员函数"></a>4.3.4 const修饰成员函数</h4><p><strong>常函数：</strong></p><ul><li>成员函数后加const后我们称为这个函数为<strong>常函数</strong></li><li>常函数内不可以修改成员属性</li><li>成员属性声明时加关键字mutable后，在常函数中依然可以修改</li></ul><p><strong>常对象：</strong></p><ul><li>声明对象前加const称该对象为常对象</li><li>常对象只能调用常函数</li></ul><p><strong>示例：</strong></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><span class="hljs-keyword">public</span>:    Person() &#123;        m_A = <span class="hljs-number">0</span>;        m_B = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">//this指针的本质是一个指针常量，指针的指向不可修改</span>    <span class="hljs-comment">//如果想让指针指向的值也不可以修改，需要声明常函数</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ShowPerson</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;        <span class="hljs-comment">//const Type* const pointer;</span>        <span class="hljs-comment">//this = NULL; //不能修改指针的指向 Person* const this;</span>        <span class="hljs-comment">//this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的</span>        <span class="hljs-comment">//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量</span>        <span class="hljs-keyword">this</span>-&gt;m_B = <span class="hljs-number">100</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MyFunc</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;        <span class="hljs-comment">//mA = 10000;</span>    &#125;<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">int</span> m_A;    <span class="hljs-keyword">mutable</span> <span class="hljs-keyword">int</span> m_B; <span class="hljs-comment">//可修改 可变的</span>&#125;;<span class="hljs-comment">//const修饰对象  常对象</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">const</span> Person person; <span class="hljs-comment">//常量对象  </span>    <span class="hljs-built_in">cout</span> &lt;&lt; person.m_A &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-comment">//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问</span>    person.m_B = <span class="hljs-number">100</span>; <span class="hljs-comment">//但是常对象可以修改mutable修饰成员变量</span>    <span class="hljs-comment">//常对象访问成员函数</span>    person.MyFunc(); <span class="hljs-comment">//常对象不能调用const的函数</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    test01();    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="4-4-友元"><a href="#4-4-友元" class="headerlink" title="4.4 友元"></a>4.4 友元</h3><p>生活中你的家有客厅(Public)，有你的卧室(Private)</p><p>客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去</p><p>但是呢，你也可以允许你的好闺蜜好基友进去。</p><p>在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p><p>友元的目的就是让一个函数或者类 访问另一个类中私有成员</p><p>友元的关键字为  ==friend==</p><p>友元的三种实现</p><ul><li>全局函数做友元</li><li>类做友元</li><li>成员函数做友元</li></ul><h4 id="4-4-1-全局函数做友元"><a href="#4-4-1-全局函数做友元" class="headerlink" title="4.4.1 全局函数做友元"></a>4.4.1 全局函数做友元</h4><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Building</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-comment">//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容</span>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">goodGay</span><span class="hljs-params">(Building * building)</span></span>;<span class="hljs-keyword">public</span>:    Building()    &#123;        <span class="hljs-keyword">this</span>-&gt;m_SittingRoom = <span class="hljs-string">&quot;客厅&quot;</span>;        <span class="hljs-keyword">this</span>-&gt;m_BedRoom = <span class="hljs-string">&quot;卧室&quot;</span>;    &#125;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">string</span> m_SittingRoom; <span class="hljs-comment">//客厅</span><span class="hljs-keyword">private</span>:    <span class="hljs-built_in">string</span> m_BedRoom; <span class="hljs-comment">//卧室</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">goodGay</span><span class="hljs-params">(Building * building)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    Building b;    goodGay(&amp;b);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    test01();    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="4-4-2-类做友元"><a href="#4-4-2-类做友元" class="headerlink" title="4.4.2 类做友元"></a>4.4.2 类做友元</h4><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Building</span>;</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">goodGay</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    goodGay();    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">()</span></span>;<span class="hljs-keyword">private</span>:    Building *building;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Building</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-comment">//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容</span>    <span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">goodGay</span>;</span><span class="hljs-keyword">public</span>:    Building();<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">string</span> m_SittingRoom; <span class="hljs-comment">//客厅</span><span class="hljs-keyword">private</span>:    <span class="hljs-built_in">string</span> m_BedRoom;<span class="hljs-comment">//卧室</span>&#125;;Building::Building()&#123;    <span class="hljs-keyword">this</span>-&gt;m_SittingRoom = <span class="hljs-string">&quot;客厅&quot;</span>;    <span class="hljs-keyword">this</span>-&gt;m_BedRoom = <span class="hljs-string">&quot;卧室&quot;</span>;&#125;goodGay::goodGay()&#123;    building = <span class="hljs-keyword">new</span> Building;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">goodGay::visit</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    goodGay gg;    gg.visit();&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    test01();    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="4-4-3-成员函数做友元"><a href="#4-4-3-成员函数做友元" class="headerlink" title="4.4.3 成员函数做友元"></a>4.4.3 成员函数做友元</h4><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Building</span>;</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">goodGay</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    goodGay();    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//只让visit函数作为Building的好朋友，可以发访问Building中私有内容</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">visit2</span><span class="hljs-params">()</span></span>; <span class="hljs-keyword">private</span>:    Building *building;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Building</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-comment">//告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容</span>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">goodGay::visit</span><span class="hljs-params">()</span></span>;<span class="hljs-keyword">public</span>:    Building();<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">string</span> m_SittingRoom; <span class="hljs-comment">//客厅</span><span class="hljs-keyword">private</span>:    <span class="hljs-built_in">string</span> m_BedRoom;<span class="hljs-comment">//卧室</span>&#125;;Building::Building()&#123;    <span class="hljs-keyword">this</span>-&gt;m_SittingRoom = <span class="hljs-string">&quot;客厅&quot;</span>;    <span class="hljs-keyword">this</span>-&gt;m_BedRoom = <span class="hljs-string">&quot;卧室&quot;</span>;&#125;goodGay::goodGay()&#123;    building = <span class="hljs-keyword">new</span> Building;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">goodGay::visit</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">goodGay::visit2</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-comment">//cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    goodGay  gg;    gg.visit();&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    test01();    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="4-5-运算符重载"><a href="#4-5-运算符重载" class="headerlink" title="4.5 运算符重载"></a>4.5 运算符重载</h3><p>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p><h4 id="4-5-1-加号运算符重载"><a href="#4-5-1-加号运算符重载" class="headerlink" title="4.5.1 加号运算符重载"></a>4.5.1 加号运算符重载</h4><p>作用：实现两个自定义数据类型相加的运算</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><span class="hljs-keyword">public</span>:    Person() &#123;&#125;;    Person(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)    &#123;        <span class="hljs-keyword">this</span>-&gt;m_A = a;        <span class="hljs-keyword">this</span>-&gt;m_B = b;    &#125;    <span class="hljs-comment">//成员函数实现 + 号运算符重载</span>    Person <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Person&amp; p) &#123;        Person temp;        temp.m_A = <span class="hljs-keyword">this</span>-&gt;m_A + p.m_A;        temp.m_B = <span class="hljs-keyword">this</span>-&gt;m_B + p.m_B;        <span class="hljs-keyword">return</span> temp;    &#125;<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">int</span> m_A;    <span class="hljs-keyword">int</span> m_B;&#125;;<span class="hljs-comment">//全局函数实现 + 号运算符重载</span><span class="hljs-comment">//Person operator+(const Person&amp; p1, const Person&amp; p2) &#123;</span><span class="hljs-comment">//    Person temp(0, 0);</span><span class="hljs-comment">//    temp.m_A = p1.m_A + p2.m_A;</span><span class="hljs-comment">//    temp.m_B = p1.m_B + p2.m_B;</span><span class="hljs-comment">//    return temp;</span><span class="hljs-comment">//&#125;</span><span class="hljs-comment">//运算符重载 可以发生函数重载 </span>Person <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Person&amp; p2, <span class="hljs-keyword">int</span> val)  &#123;    Person temp;    temp.m_A = p2.m_A + val;    temp.m_B = p2.m_B + val;    <span class="hljs-keyword">return</span> temp;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>)</span></span>;    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">20</span>, <span class="hljs-number">20</span>)</span></span>;    <span class="hljs-comment">//成员函数方式</span>    Person p3 = p2 + p1;  <span class="hljs-comment">//相当于 p2.operaor+(p1)</span>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;mA:&quot;</span> &lt;&lt; p3.m_A &lt;&lt; <span class="hljs-string">&quot; mB:&quot;</span> &lt;&lt; p3.m_B &lt;&lt; <span class="hljs-built_in">endl</span>;    Person p4 = p3 + <span class="hljs-number">10</span>; <span class="hljs-comment">//相当于 operator+(p3,10)</span>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;mA:&quot;</span> &lt;&lt; p4.m_A &lt;&lt; <span class="hljs-string">&quot; mB:&quot;</span> &lt;&lt; p4.m_B &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    test();    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><blockquote><p>总结1：对于内置的数据类型的表达式的的运算符是不可能改变的</p></blockquote><blockquote><p>总结2：不要滥用运算符重载</p></blockquote><h4 id="4-5-2-左移运算符重载"><a href="#4-5-2-左移运算符重载" class="headerlink" title="4.5.2 左移运算符重载"></a>4.5.2 左移运算符重载</h4><p>作用：可以输出自定义数据类型</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span>    <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p);<span class="hljs-keyword">public</span>:    Person(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)    &#123;        <span class="hljs-keyword">this</span>-&gt;m_A = a;        <span class="hljs-keyword">this</span>-&gt;m_B = b;    &#125;    <span class="hljs-comment">//成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果</span>    <span class="hljs-comment">//void operator&lt;&lt;(Person&amp; p)&#123;</span>    <span class="hljs-comment">//&#125;</span><span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> m_A;    <span class="hljs-keyword">int</span> m_B;&#125;;<span class="hljs-comment">//全局函数实现左移重载</span><span class="hljs-comment">//ostream对象只能有一个</span>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p) &#123;    out &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; p.m_A &lt;&lt; <span class="hljs-string">&quot; b:&quot;</span> &lt;&lt; p.m_B;    <span class="hljs-keyword">return</span> out;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)</span></span>;    <span class="hljs-built_in">cout</span> &lt;&lt; p1 &lt;&lt; <span class="hljs-string">&quot;hello world&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">//链式编程</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    test();    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><blockquote><p>总结：重载左移运算符配合友元可以实现输出自定义数据类型</p></blockquote><h4 id="4-5-3-递增运算符重载"><a href="#4-5-3-递增运算符重载" class="headerlink" title="4.5.3 递增运算符重载"></a>4.5.3 递增运算符重载</h4><p>作用： 通过重载递增运算符，实现自己的整型数据</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInteger</span> &#123;</span>    <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint);<span class="hljs-keyword">public</span>:    MyInteger() &#123;        m_Num = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">//前置++</span>    MyInteger&amp; <span class="hljs-keyword">operator</span>++() &#123;        <span class="hljs-comment">//先++</span>        m_Num++;        <span class="hljs-comment">//再返回</span>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">//后置++</span>    MyInteger <span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>) &#123;        <span class="hljs-comment">//先返回</span>        MyInteger temp = *<span class="hljs-keyword">this</span>; <span class="hljs-comment">//记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；</span>        m_Num++;        <span class="hljs-keyword">return</span> temp;    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> m_Num;&#125;;ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint) &#123;    out &lt;&lt; myint.m_Num;    <span class="hljs-keyword">return</span> out;&#125;<span class="hljs-comment">//前置++ 先++ 再返回</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;    MyInteger myInt;    <span class="hljs-built_in">cout</span> &lt;&lt; ++myInt &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; myInt &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-comment">//后置++ 先返回 再++</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;    MyInteger myInt;    <span class="hljs-built_in">cout</span> &lt;&lt; myInt++ &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; myInt &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    test01();    <span class="hljs-comment">//test02();</span>    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><blockquote><p>总结： 前置递增返回引用，后置递增返回值</p></blockquote><h4 id="4-5-4-赋值运算符重载"><a href="#4-5-4-赋值运算符重载" class="headerlink" title="4.5.4 赋值运算符重载"></a>4.5.4 赋值运算符重载</h4><p>c++编译器至少给一个类添加4个函数</p><ol><li>默认构造函数(无参，函数体为空)</li><li>默认析构函数(无参，函数体为空)</li><li>默认拷贝构造函数，对属性进行值拷贝</li><li>赋值运算符 operator=, 对属性进行值拷贝</li></ol><p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p><p><strong>示例：</strong></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    Person(<span class="hljs-keyword">int</span> age)    &#123;        <span class="hljs-comment">//将年龄数据开辟到堆区</span>        m_Age = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(age);    &#125;    <span class="hljs-comment">//重载赋值运算符 </span>    Person&amp; <span class="hljs-keyword">operator</span>=(Person &amp;p)    &#123;        <span class="hljs-keyword">if</span> (m_Age != <span class="hljs-literal">NULL</span>)        &#123;            <span class="hljs-keyword">delete</span> m_Age;            m_Age = <span class="hljs-literal">NULL</span>;        &#125;        <span class="hljs-comment">//编译器提供的代码是浅拷贝</span>        <span class="hljs-comment">//m_Age = p.m_Age;</span>        <span class="hljs-comment">//提供深拷贝 解决浅拷贝的问题</span>        m_Age = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(*p.m_Age);        <span class="hljs-comment">//返回自身</span>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;    &#125;    ~Person()    &#123;        <span class="hljs-keyword">if</span> (m_Age != <span class="hljs-literal">NULL</span>)        &#123;            <span class="hljs-keyword">delete</span> m_Age;            m_Age = <span class="hljs-literal">NULL</span>;        &#125;    &#125;    <span class="hljs-comment">//年龄的指针</span>    <span class="hljs-keyword">int</span> *m_Age;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">18</span>)</span></span>;    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;    <span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-number">30</span>)</span></span>;    p3 = p2 = p1; <span class="hljs-comment">//赋值操作</span>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;p1的年龄为：&quot;</span> &lt;&lt; *p1.m_Age &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;p2的年龄为：&quot;</span> &lt;&lt; *p2.m_Age &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;p3的年龄为：&quot;</span> &lt;&lt; *p3.m_Age &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    test01();    <span class="hljs-comment">//int a = 10;</span>    <span class="hljs-comment">//int b = 20;</span>    <span class="hljs-comment">//int c = 30;</span>    <span class="hljs-comment">//c = b = a;</span>    <span class="hljs-comment">//cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;</span>    <span class="hljs-comment">//cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;</span>    <span class="hljs-comment">//cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;</span>    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="4-5-5-关系运算符重载"><a href="#4-5-5-关系运算符重载" class="headerlink" title="4.5.5 关系运算符重载"></a>4.5.5 关系运算符重载</h4><p><strong>作用：</strong>重载关系运算符，可以让两个自定义类型对象进行对比操作</p><p><strong>示例：</strong></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    Person(<span class="hljs-built_in">string</span> name, <span class="hljs-keyword">int</span> age)    &#123;        <span class="hljs-keyword">this</span>-&gt;m_Name = name;        <span class="hljs-keyword">this</span>-&gt;m_Age = age;    &#125;;    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(Person &amp; p)    &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="hljs-keyword">this</span>-&gt;m_Age == p.m_Age)        &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">else</span>        &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;    &#125;    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(Person &amp; p)    &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="hljs-keyword">this</span>-&gt;m_Age == p.m_Age)        &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">else</span>        &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;    &#125;    <span class="hljs-built_in">string</span> m_Name;    <span class="hljs-keyword">int</span> m_Age;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//int a = 0;</span>    <span class="hljs-comment">//int b = 0;</span>    <span class="hljs-function">Person <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-string">&quot;孙悟空&quot;</span>, <span class="hljs-number">18</span>)</span></span>;    <span class="hljs-function">Person <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-string">&quot;孙悟空&quot;</span>, <span class="hljs-number">18</span>)</span></span>;    <span class="hljs-keyword">if</span> (a == b)    &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;a和b相等&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;a和b不相等&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-keyword">if</span> (a != b)    &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;a和b不相等&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;a和b相等&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    test01();    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="4-5-6-函数调用运算符重载"><a href="#4-5-6-函数调用运算符重载" class="headerlink" title="4.5.6 函数调用运算符重载"></a>4.5.6 函数调用运算符重载</h4><ul><li>函数调用运算符 ()  也可以重载</li><li>由于重载后使用的方式非常像函数的调用，因此称为仿函数</li><li>仿函数没有固定写法，非常灵活</li></ul><p><strong>示例：</strong></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPrint</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-built_in">string</span> <span class="hljs-built_in">text</span>)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">text</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//重载的（）操作符 也称为仿函数</span>    MyPrint myFunc;    myFunc(<span class="hljs-string">&quot;hello world&quot;</span>);&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAdd</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v1, <span class="hljs-keyword">int</span> v2)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> v1 + v2;    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    MyAdd add;    <span class="hljs-keyword">int</span> ret = add(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>);    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;ret = &quot;</span> &lt;&lt; ret &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-comment">//匿名对象调用  </span>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;MyAdd()(100,100) = &quot;</span> &lt;&lt; MyAdd()(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    test01();    test02();    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="4-6-继承"><a href="#4-6-继承" class="headerlink" title="4.6  继承"></a>4.6  继承</h3><p><strong>继承是面向对象三大特性之一</strong></p><p>有些类与类之间存在特殊的关系，例如下图中：</p><p><img src="./1544861202252.png" alt="1544861202252"></p><p>我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。</p><p>这个时候我们就可以考虑利用继承的技术，减少重复代码</p><h4 id="4-6-1-继承的基本语法"><a href="#4-6-1-继承的基本语法" class="headerlink" title="4.6.1 继承的基本语法"></a>4.6.1 继承的基本语法</h4><p>例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同</p><p>接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处</p><p><strong>普通实现：</strong></p><pre><code class="hljs C++"><span class="hljs-comment">//Java页面</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Java</span> </span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">header</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">footer</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">left</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;JAVA学科视频&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;;<span class="hljs-comment">//Python页面</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Python</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">header</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">footer</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">left</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Python学科视频&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;;<span class="hljs-comment">//C++页面</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CPP</span> </span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">header</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">footer</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">left</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;C++学科视频&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//Java页面</span>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    Java ja;    ja.header();    ja.footer();    ja.left();    ja.content();    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;--------------------&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-comment">//Python页面</span>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    Python py;    py.header();    py.footer();    py.left();    py.content();    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;--------------------&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-comment">//C++页面</span>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    CPP cp;    cp.header();    cp.footer();    cp.left();    cp.content();&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    test01();    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>继承实现：</strong></p><pre><code class="hljs C++"><span class="hljs-comment">//公共页面</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasePage</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">header</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">footer</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">left</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;;<span class="hljs-comment">//Java页面</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Java</span> :</span> <span class="hljs-keyword">public</span> BasePage&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;JAVA学科视频&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;;<span class="hljs-comment">//Python页面</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Python</span> :</span> <span class="hljs-keyword">public</span> BasePage&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Python学科视频&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;;<span class="hljs-comment">//C++页面</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CPP</span> :</span> <span class="hljs-keyword">public</span> BasePage&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;C++学科视频&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//Java页面</span>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    Java ja;    ja.header();    ja.footer();    ja.left();    ja.content();    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;--------------------&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-comment">//Python页面</span>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    Python py;    py.header();    py.footer();    py.left();    py.content();    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;--------------------&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-comment">//C++页面</span>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    CPP cp;    cp.header();    cp.footer();    cp.left();    cp.content();&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    test01();    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>总结：</strong></p><p>继承的好处：==可以减少重复的代码==</p><p>class A : public B; </p><p>A 类称为子类 或 派生类</p><p>B 类称为父类 或 基类</p><p><strong>派生类中的成员，包含两大部分</strong>：</p><p>一类是从基类继承过来的，一类是自己增加的成员。</p><p>从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p><h4 id="4-6-2-继承方式"><a href="#4-6-2-继承方式" class="headerlink" title="4.6.2 继承方式"></a>4.6.2 继承方式</h4><p>继承的语法：<code>class 子类 : 继承方式  父类</code></p><p><strong>继承方式一共有三种：</strong></p><ul><li>公共继承</li><li>保护继承</li><li>私有继承</li></ul><p><img src="./clip_image002.png" alt="img"></p><p><strong>示例：</strong></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base1</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:     <span class="hljs-keyword">int</span> m_A;<span class="hljs-keyword">protected</span>:    <span class="hljs-keyword">int</span> m_B;<span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> m_C;&#125;;<span class="hljs-comment">//公共继承</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son1</span> :</span><span class="hljs-keyword">public</span> Base1&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        m_A; <span class="hljs-comment">//可访问 public权限</span>        m_B; <span class="hljs-comment">//可访问 protected权限</span>        <span class="hljs-comment">//m_C; //不可访问</span>    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">myClass</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    Son1 s1;    s1.m_A; <span class="hljs-comment">//其他类只能访问到公共权限</span>&#125;<span class="hljs-comment">//保护继承</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base2</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">int</span> m_A;<span class="hljs-keyword">protected</span>:    <span class="hljs-keyword">int</span> m_B;<span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> m_C;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son2</span>:</span><span class="hljs-keyword">protected</span> Base2&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        m_A; <span class="hljs-comment">//可访问 protected权限</span>        m_B; <span class="hljs-comment">//可访问 protected权限</span>        <span class="hljs-comment">//m_C; //不可访问</span>    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">myClass2</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    Son2 s;    <span class="hljs-comment">//s.m_A; //不可访问</span>&#125;<span class="hljs-comment">//私有继承</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base3</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">int</span> m_A;<span class="hljs-keyword">protected</span>:    <span class="hljs-keyword">int</span> m_B;<span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> m_C;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son3</span>:</span><span class="hljs-keyword">private</span> Base3&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        m_A; <span class="hljs-comment">//可访问 private权限</span>        m_B; <span class="hljs-comment">//可访问 private权限</span>        <span class="hljs-comment">//m_C; //不可访问</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GrandSon3</span> :</span><span class="hljs-keyword">public</span> Son3&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-comment">//Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到</span>        <span class="hljs-comment">//m_A;</span>        <span class="hljs-comment">//m_B;</span>        <span class="hljs-comment">//m_C;</span>    &#125;&#125;;</code></pre><h4 id="4-6-3-继承中的对象模型"><a href="#4-6-3-继承中的对象模型" class="headerlink" title="4.6.3 继承中的对象模型"></a>4.6.3 继承中的对象模型</h4><p><strong>问题：</strong>从父类继承过来的成员，哪些属于子类对象中？</p><p><strong>示例：</strong></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">int</span> m_A;<span class="hljs-keyword">protected</span>:    <span class="hljs-keyword">int</span> m_B;<span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> m_C; <span class="hljs-comment">//私有成员只是被隐藏了，但是还是会继承下去</span>&#125;;<span class="hljs-comment">//公共继承</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> :</span><span class="hljs-keyword">public</span> Base&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">int</span> m_D;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(Son) &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    test01();    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>利用工具查看：</p><p><img src="./1545881904150.png" alt="1545881904150"></p><p>打开工具窗口后，定位到当前CPP文件的盘符</p><p>然后输入： cl /d1 reportSingleClassLayout查看的类名   所属文件名</p><p>效果如下图：</p><p><img src="./1545882158050.png" alt="1545882158050"></p><blockquote><p>结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p></blockquote><h4 id="4-6-4-继承中构造和析构顺序"><a href="#4-6-4-继承中构造和析构顺序" class="headerlink" title="4.6.4 继承中构造和析构顺序"></a>4.6.4 继承中构造和析构顺序</h4><p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p><p>问题：父类和子类的构造和析构顺序是谁先谁后？</p><p><strong>示例：</strong></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> </span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    Base()    &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Base构造函数!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    ~Base()    &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Base析构函数!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> :</span> <span class="hljs-keyword">public</span> Base&#123;<span class="hljs-keyword">public</span>:    Son()    &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Son构造函数!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    ~Son()    &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Son析构函数!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</span>    Son s;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    test01();    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><blockquote><p>总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p></blockquote><h4 id="4-6-5-继承同名成员处理方式"><a href="#4-6-5-继承同名成员处理方式" class="headerlink" title="4.6.5 继承同名成员处理方式"></a>4.6.5 继承同名成员处理方式</h4><p>问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p><ul><li>访问子类同名成员   直接访问即可</li><li>访问父类同名成员   需要加作用域</li></ul><p><strong>示例：</strong></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> &#123;</span><span class="hljs-keyword">public</span>:    Base()    &#123;        m_A = <span class="hljs-number">100</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Base - func()调用&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Base - func(int a)调用&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">int</span> m_A;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> :</span> <span class="hljs-keyword">public</span> Base &#123;<span class="hljs-keyword">public</span>:    Son()    &#123;        m_A = <span class="hljs-number">200</span>;    &#125;    <span class="hljs-comment">//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数</span>    <span class="hljs-comment">//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Son - func()调用&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">int</span> m_A;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    Son s;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Son下的m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Base下的m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; <span class="hljs-built_in">endl</span>;    s.func();    s.Base::func();    s.Base::func(<span class="hljs-number">10</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    test01();    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> EXIT_SUCCESS;&#125;</code></pre><p>总结：</p><ol><li>子类对象可以直接访问到子类中同名成员</li><li>子类对象加作用域可以访问到父类同名成员</li><li>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</li></ol><h4 id="4-6-6-继承同名静态成员处理方式"><a href="#4-6-6-继承同名静态成员处理方式" class="headerlink" title="4.6.6 继承同名静态成员处理方式"></a>4.6.6 继承同名静态成员处理方式</h4><p>问题：继承中同名的静态成员在子类对象上如何进行访问？</p><p>静态成员和非静态成员出现同名，处理方式一致</p><ul><li>访问子类同名成员   直接访问即可</li><li>访问父类同名成员   需要加作用域</li></ul><p><strong>示例：</strong></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Base - static void func()&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Base - static void func(int a)&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> m_A;&#125;;<span class="hljs-keyword">int</span> Base::m_A = <span class="hljs-number">100</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> :</span> <span class="hljs-keyword">public</span> Base &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Son - static void func()&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> m_A;&#125;;<span class="hljs-keyword">int</span> Son::m_A = <span class="hljs-number">200</span>;<span class="hljs-comment">//同名成员属性</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//通过对象访问</span>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;通过对象访问： &quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    Son s;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-comment">//通过类名访问</span>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;通过类名访问： &quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; Son::m_A &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; Son::Base::m_A &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-comment">//同名成员函数</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//通过对象访问</span>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;通过对象访问： &quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    Son s;    s.func();    s.Base::func();    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;通过类名访问： &quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    Son::func();    Son::Base::func();    <span class="hljs-comment">//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问</span>    Son::Base::func(<span class="hljs-number">100</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//test01();</span>    test02();    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><blockquote><p>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）</p></blockquote><h4 id="4-6-7-多继承语法"><a href="#4-6-7-多继承语法" class="headerlink" title="4.6.7 多继承语法"></a>4.6.7 多继承语法</h4><p>C++允许<strong>一个类继承多个类</strong></p><p>语法：<code> class 子类 ：继承方式 父类1 ， 继承方式 父类2...</code></p><p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p><p><strong>C++实际开发中不建议用多继承</strong></p><p><strong>示例：</strong></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base1</span> &#123;</span><span class="hljs-keyword">public</span>:    Base1()    &#123;        m_A = <span class="hljs-number">100</span>;    &#125;<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">int</span> m_A;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base2</span> &#123;</span><span class="hljs-keyword">public</span>:    Base2()    &#123;        m_A = <span class="hljs-number">200</span>;  <span class="hljs-comment">//开始是m_B 不会出问题，但是改为mA就会出现不明确</span>    &#125;<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">int</span> m_A;&#125;;<span class="hljs-comment">//语法：class 子类：继承方式 父类1 ，继承方式 父类2 </span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> :</span> <span class="hljs-keyword">public</span> Base2, <span class="hljs-keyword">public</span> Base1 &#123;<span class="hljs-keyword">public</span>:    Son()    &#123;        m_C = <span class="hljs-number">300</span>;        m_D = <span class="hljs-number">400</span>;    &#125;<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">int</span> m_C;    <span class="hljs-keyword">int</span> m_D;&#125;;<span class="hljs-comment">//多继承容易产生成员同名的情况</span><span class="hljs-comment">//通过使用类名作用域可以区分调用哪一个基类的成员</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    Son s;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(s) &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; s.Base1::m_A &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; s.Base2::m_A &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    test01();    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><blockquote><p>总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p></blockquote><h4 id="4-6-8-菱形继承"><a href="#4-6-8-菱形继承" class="headerlink" title="4.6.8 菱形继承"></a>4.6.8 菱形继承</h4><p><strong>菱形继承概念：</strong></p><p>​    两个派生类继承同一个基类</p><p>​    又有某个类同时继承者两个派生类</p><p>​    这种继承被称为菱形继承，或者钻石继承</p><p><strong>典型的菱形继承案例：</strong></p><p><img src="./clip_image002.jpg" alt="IMG_256"></p><p><strong>菱形继承问题：</strong></p><ol><li><p>羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。</p></li><li><p>草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。</p></li></ol><p><strong>示例：</strong></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">int</span> m_Age;&#125;;<span class="hljs-comment">//继承前加virtual关键字后，变为虚继承</span><span class="hljs-comment">//此时公共的父类Animal称为虚基类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sheep</span> :</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Animal &#123;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tuo</span>   :</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Animal &#123;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SheepTuo</span> :</span> <span class="hljs-keyword">public</span> Sheep, <span class="hljs-keyword">public</span> Tuo &#123;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    SheepTuo st;    st.Sheep::m_Age = <span class="hljs-number">100</span>;    st.Tuo::m_Age = <span class="hljs-number">200</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;st.Sheep::m_Age = &quot;</span> &lt;&lt; st.Sheep::m_Age &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;st.Tuo::m_Age = &quot;</span> &lt;&lt;  st.Tuo::m_Age &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;st.m_Age = &quot;</span> &lt;&lt; st.m_Age &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    test01();    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>总结：</p><ul><li>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</li><li>利用虚继承可以解决菱形继承问题</li></ul><h3 id="4-7-多态"><a href="#4-7-多态" class="headerlink" title="4.7  多态"></a>4.7  多态</h3><h4 id="4-7-1-多态的基本概念"><a href="#4-7-1-多态的基本概念" class="headerlink" title="4.7.1 多态的基本概念"></a>4.7.1 多态的基本概念</h4><p><strong>多态是C++面向对象三大特性之一</strong></p><p>多态分为两类</p><ul><li>静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名</li><li>动态多态: 派生类和虚函数实现运行时多态</li></ul><p>静态多态和动态多态区别：</p><ul><li>静态多态的函数地址早绑定  -  编译阶段确定函数地址</li><li>动态多态的函数地址晚绑定  -  运行阶段确定函数地址</li></ul><p>下面通过案例进行讲解多态</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-comment">//Speak函数就是虚函数</span>    <span class="hljs-comment">//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;动物在说话&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> :</span><span class="hljs-keyword">public</span> Animal&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;小猫在说话&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> :</span><span class="hljs-keyword">public</span> Animal&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;小狗在说话&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;;<span class="hljs-comment">//我们希望传入什么对象，那么就调用什么对象的函数</span><span class="hljs-comment">//如果函数地址在编译阶段就能确定，那么静态联编</span><span class="hljs-comment">//如果函数地址在运行阶段才能确定，就是动态联编</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoSpeak</span><span class="hljs-params">(Animal &amp; animal)</span></span><span class="hljs-function"></span>&#123;    animal.speak();&#125;<span class="hljs-comment">//</span><span class="hljs-comment">//多态满足条件： </span><span class="hljs-comment">//1、有继承关系</span><span class="hljs-comment">//2、子类重写父类中的虚函数</span><span class="hljs-comment">//多态使用：</span><span class="hljs-comment">//父类指针或引用指向子类对象</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    Cat cat;    DoSpeak(cat);    Dog dog;    DoSpeak(dog);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    test01();    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>总结：</p><p>多态满足条件</p><ul><li>有继承关系</li><li>子类重写父类中的虚函数</li></ul><p>多态使用条件</p><ul><li>父类指针或引用指向子类对象</li></ul><p>重写：函数返回值类型  函数名 参数列表 完全一致称为重写</p><h4 id="4-7-2-多态案例一-计算器类"><a href="#4-7-2-多态案例一-计算器类" class="headerlink" title="4.7.2 多态案例一-计算器类"></a>4.7.2 多态案例一-计算器类</h4><p>案例描述：</p><p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p><p>多态的优点：</p><ul><li>代码组织结构清晰</li><li>可读性强</li><li>利于前期和后期的扩展以及维护</li></ul><p><strong>示例：</strong></p><pre><code class="hljs C++"><span class="hljs-comment">//普通实现</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Calculator</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">(<span class="hljs-built_in">string</span> oper)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span> (oper == <span class="hljs-string">&quot;+&quot;</span>) &#123;            <span class="hljs-keyword">return</span> m_Num1 + m_Num2;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oper == <span class="hljs-string">&quot;-&quot;</span>) &#123;            <span class="hljs-keyword">return</span> m_Num1 - m_Num2;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oper == <span class="hljs-string">&quot;*&quot;</span>) &#123;            <span class="hljs-keyword">return</span> m_Num1 * m_Num2;        &#125;        <span class="hljs-comment">//如果要提供新的运算，需要修改源码</span>    &#125;<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">int</span> m_Num1;    <span class="hljs-keyword">int</span> m_Num2;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//普通实现测试</span>    Calculator c;    c.m_Num1 = <span class="hljs-number">10</span>;    c.m_Num2 = <span class="hljs-number">10</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; c.m_Num1 &lt;&lt; <span class="hljs-string">&quot; + &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; c.<span class="hljs-built_in">getResult</span>(<span class="hljs-string">&quot;+&quot;</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; c.m_Num1 &lt;&lt; <span class="hljs-string">&quot; - &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; c.<span class="hljs-built_in">getResult</span>(<span class="hljs-string">&quot;-&quot;</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; c.m_Num1 &lt;&lt; <span class="hljs-string">&quot; * &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; c.<span class="hljs-built_in">getResult</span>(<span class="hljs-string">&quot;*&quot;</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-comment">//多态实现</span><span class="hljs-comment">//抽象计算器类</span><span class="hljs-comment">//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractCalculator</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span> :    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> m_Num1;    <span class="hljs-keyword">int</span> m_Num2;&#125;;<span class="hljs-comment">//加法计算器</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddCalculator</span> :</span><span class="hljs-keyword">public</span> AbstractCalculator&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> m_Num1 + m_Num2;    &#125;&#125;;<span class="hljs-comment">//减法计算器</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubCalculator</span> :</span><span class="hljs-keyword">public</span> AbstractCalculator&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> m_Num1 - m_Num2;    &#125;&#125;;<span class="hljs-comment">//乘法计算器</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MulCalculator</span> :</span><span class="hljs-keyword">public</span> AbstractCalculator&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> m_Num1 * m_Num2;    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//创建加法计算器</span>    AbstractCalculator *abc = <span class="hljs-keyword">new</span> AddCalculator;    abc-&gt;m_Num1 = <span class="hljs-number">10</span>;    abc-&gt;m_Num2 = <span class="hljs-number">10</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="hljs-string">&quot; + &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="hljs-built_in">getResult</span>() &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">delete</span> abc;  <span class="hljs-comment">//用完了记得销毁</span>    <span class="hljs-comment">//创建减法计算器</span>    abc = <span class="hljs-keyword">new</span> SubCalculator;    abc-&gt;m_Num1 = <span class="hljs-number">10</span>;    abc-&gt;m_Num2 = <span class="hljs-number">10</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="hljs-string">&quot; - &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="hljs-built_in">getResult</span>() &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">delete</span> abc;      <span class="hljs-comment">//创建乘法计算器</span>    abc = <span class="hljs-keyword">new</span> MulCalculator;    abc-&gt;m_Num1 = <span class="hljs-number">10</span>;    abc-&gt;m_Num2 = <span class="hljs-number">10</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="hljs-string">&quot; * &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="hljs-built_in">getResult</span>() &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">delete</span> abc;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//test01();</span>    test02();    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><blockquote><p>总结：C++开发提倡利用多态设计程序架构，因为多态优点很多</p></blockquote><h4 id="4-7-3-纯虚函数和抽象类"><a href="#4-7-3-纯虚函数和抽象类" class="headerlink" title="4.7.3 纯虚函数和抽象类"></a>4.7.3 纯虚函数和抽象类</h4><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p><p>因此可以将虚函数改为<strong>纯虚函数</strong></p><p>纯虚函数语法：<code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code></p><p>当类中有了纯虚函数，这个类也称为==抽象类==</p><p><strong>抽象类特点</strong>：</p><ul><li>无法实例化对象</li><li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li></ul><p><strong>示例：</strong></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-comment">//纯虚函数</span>    <span class="hljs-comment">//类中只要有一个纯虚函数就称为抽象类</span>    <span class="hljs-comment">//抽象类无法实例化对象</span>    <span class="hljs-comment">//子类必须重写父类中的纯虚函数，否则也属于抽象类</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> :</span><span class="hljs-keyword">public</span> Base&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;func调用&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    Base * base = <span class="hljs-literal">NULL</span>;    <span class="hljs-comment">//base = new Base; // 错误，抽象类无法实例化对象</span>    base = <span class="hljs-keyword">new</span> Son;    base-&gt;func();    <span class="hljs-keyword">delete</span> base;<span class="hljs-comment">//记得销毁</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    test01();    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="4-7-4-多态案例二-制作饮品"><a href="#4-7-4-多态案例二-制作饮品" class="headerlink" title="4.7.4 多态案例二-制作饮品"></a>4.7.4 多态案例二-制作饮品</h4><p><strong>案例描述：</strong></p><p>制作饮品的大致流程为：煮水 -  冲泡 - 倒入杯中 - 加入辅料</p><p>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶</p><p><img src="./1545985945198.png" alt="1545985945198"></p><p><strong>示例：</strong></p><pre><code class="hljs C++"><span class="hljs-comment">//抽象制作饮品</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractDrinking</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-comment">//烧水</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Boil</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-comment">//冲泡</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Brew</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-comment">//倒入杯中</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PourInCup</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-comment">//加入辅料</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PutSomething</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-comment">//规定流程</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MakeDrink</span><span class="hljs-params">()</span> </span>&#123;        Boil();        Brew();        PourInCup();        PutSomething();    &#125;&#125;;<span class="hljs-comment">//制作咖啡</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Coffee</span> :</span> <span class="hljs-keyword">public</span> AbstractDrinking &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-comment">//烧水</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Boil</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;煮农夫山泉!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-comment">//冲泡</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Brew</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;冲泡咖啡!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-comment">//倒入杯中</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PourInCup</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;将咖啡倒入杯中!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-comment">//加入辅料</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PutSomething</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;加入牛奶!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;;<span class="hljs-comment">//制作茶水</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tea</span> :</span> <span class="hljs-keyword">public</span> AbstractDrinking &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-comment">//烧水</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Boil</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;煮自来水!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-comment">//冲泡</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Brew</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;冲泡茶叶!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-comment">//倒入杯中</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PourInCup</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;将茶水倒入杯中!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-comment">//加入辅料</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PutSomething</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;加入枸杞!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;;<span class="hljs-comment">//业务函数</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoWork</span><span class="hljs-params">(AbstractDrinking* drink)</span> </span>&#123;    drink-&gt;MakeDrink();    <span class="hljs-keyword">delete</span> drink;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;    DoWork(<span class="hljs-keyword">new</span> Coffee);    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;--------------&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    DoWork(<span class="hljs-keyword">new</span> Tea);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    test01();    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="4-7-5-虚析构和纯虚析构"><a href="#4-7-5-虚析构和纯虚析构" class="headerlink" title="4.7.5 虚析构和纯虚析构"></a>4.7.5 虚析构和纯虚析构</h4><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p><p>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p><p>虚析构和纯虚析构共性：</p><ul><li>可以解决父类指针释放子类对象</li><li>都需要有具体的函数实现</li></ul><p>虚析构和纯虚析构区别：</p><ul><li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li></ul><p>虚析构语法：</p><p><code>virtual ~类名()&#123;&#125;</code></p><p>纯虚析构语法：</p><p><code> virtual ~类名() = 0;</code></p><p><code>类名::~类名()&#123;&#125;</code></p><p><strong>示例：</strong></p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> &#123;</span><span class="hljs-keyword">public</span>:    Animal()    &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Animal 构造函数调用！&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-comment">//析构函数加上virtual关键字，变成虚析构函数</span>    <span class="hljs-comment">//virtual ~Animal()</span>    <span class="hljs-comment">//&#123;</span>    <span class="hljs-comment">//    cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;</span>    <span class="hljs-comment">//&#125;</span>    <span class="hljs-keyword">virtual</span> ~Animal() = <span class="hljs-number">0</span>;&#125;;Animal::~Animal()&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Animal 纯虚析构函数调用！&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-comment">//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> :</span> <span class="hljs-keyword">public</span> Animal &#123;<span class="hljs-keyword">public</span>:    Cat(<span class="hljs-built_in">string</span> name)    &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Cat构造函数调用！&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        m_Name = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(name);    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; *m_Name &lt;&lt;  <span class="hljs-string">&quot;小猫在说话!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    ~Cat()    &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Cat析构函数调用!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;m_Name != <span class="hljs-literal">NULL</span>) &#123;            <span class="hljs-keyword">delete</span> m_Name;            m_Name = <span class="hljs-literal">NULL</span>;        &#125;    &#125;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">string</span> *m_Name;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    Animal *animal = <span class="hljs-keyword">new</span> Cat(<span class="hljs-string">&quot;Tom&quot;</span>);    animal-&gt;Speak();    <span class="hljs-comment">//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏</span>    <span class="hljs-comment">//怎么解决？给基类增加一个虚析构函数</span>    <span class="hljs-comment">//虚析构函数就是用来解决通过父类指针释放子类对象</span>    <span class="hljs-keyword">delete</span> animal;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    test01();    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>总结：</p><p>​    1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</p><p>​    2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</p><p>​    3. 拥有纯虚析构函数的类也属于抽象类</p><h4 id="4-7-6-多态案例三-电脑组装"><a href="#4-7-6-多态案例三-电脑组装" class="headerlink" title="4.7.6 多态案例三-电脑组装"></a>4.7.6 多态案例三-电脑组装</h4><p><strong>案例描述：</strong></p><p>电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）</p><p>将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商</p><p>创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口</p><p>测试时组装三台不同的电脑进行工作</p><p><strong>示例：</strong></p><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-comment">//抽象CPU类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CPU</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-comment">//抽象的计算函数</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">calculate</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;&#125;;<span class="hljs-comment">//抽象显卡类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VideoCard</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-comment">//抽象的显示函数</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;&#125;;<span class="hljs-comment">//抽象内存条类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Memory</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-comment">//抽象的存储函数</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">storage</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;&#125;;<span class="hljs-comment">//电脑类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Computer</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    Computer(CPU * cpu, VideoCard * vc, Memory * mem)    &#123;        m_cpu = cpu;        m_vc = vc;        m_mem = mem;    &#125;    <span class="hljs-comment">//提供工作的函数</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-comment">//让零件工作起来，调用接口</span>        m_cpu-&gt;calculate();        m_vc-&gt;<span class="hljs-built_in">display</span>();        m_mem-&gt;storage();    &#125;    <span class="hljs-comment">//提供析构函数 释放3个电脑零件</span>    ~Computer()    &#123;        <span class="hljs-comment">//释放CPU零件</span>        <span class="hljs-keyword">if</span> (m_cpu != <span class="hljs-literal">NULL</span>)        &#123;            <span class="hljs-keyword">delete</span> m_cpu;            m_cpu = <span class="hljs-literal">NULL</span>;        &#125;        <span class="hljs-comment">//释放显卡零件</span>        <span class="hljs-keyword">if</span> (m_vc != <span class="hljs-literal">NULL</span>)        &#123;            <span class="hljs-keyword">delete</span> m_vc;            m_vc = <span class="hljs-literal">NULL</span>;        &#125;        <span class="hljs-comment">//释放内存条零件</span>        <span class="hljs-keyword">if</span> (m_mem != <span class="hljs-literal">NULL</span>)        &#123;            <span class="hljs-keyword">delete</span> m_mem;            m_mem = <span class="hljs-literal">NULL</span>;        &#125;    &#125;<span class="hljs-keyword">private</span>:    CPU * m_cpu; <span class="hljs-comment">//CPU的零件指针</span>    VideoCard * m_vc; <span class="hljs-comment">//显卡零件指针</span>    Memory * m_mem; <span class="hljs-comment">//内存条零件指针</span>&#125;;<span class="hljs-comment">//具体厂商</span><span class="hljs-comment">//Intel厂商</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntelCPU</span> :</span><span class="hljs-keyword">public</span> CPU&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">calculate</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Intel的CPU开始计算了！&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntelVideoCard</span> :</span><span class="hljs-keyword">public</span> VideoCard&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Intel的显卡开始显示了！&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntelMemory</span> :</span><span class="hljs-keyword">public</span> Memory&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">storage</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Intel的内存条开始存储了！&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;;<span class="hljs-comment">//Lenovo厂商</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LenovoCPU</span> :</span><span class="hljs-keyword">public</span> CPU&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">calculate</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Lenovo的CPU开始计算了！&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LenovoVideoCard</span> :</span><span class="hljs-keyword">public</span> VideoCard&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Lenovo的显卡开始显示了！&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LenovoMemory</span> :</span><span class="hljs-keyword">public</span> Memory&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">storage</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Lenovo的内存条开始存储了！&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//第一台电脑零件</span>    CPU * intelCpu = <span class="hljs-keyword">new</span> IntelCPU;    VideoCard * intelCard = <span class="hljs-keyword">new</span> IntelVideoCard;    Memory * intelMem = <span class="hljs-keyword">new</span> IntelMemory;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;第一台电脑开始工作：&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-comment">//创建第一台电脑</span>    Computer * computer1 = <span class="hljs-keyword">new</span> Computer(intelCpu, intelCard, intelMem);    computer1-&gt;work();    <span class="hljs-keyword">delete</span> computer1;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;-----------------------&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;第二台电脑开始工作：&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-comment">//第二台电脑组装</span>    Computer * computer2 = <span class="hljs-keyword">new</span> Computer(<span class="hljs-keyword">new</span> LenovoCPU, <span class="hljs-keyword">new</span> LenovoVideoCard, <span class="hljs-keyword">new</span> LenovoMemory);;    computer2-&gt;work();    <span class="hljs-keyword">delete</span> computer2;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;-----------------------&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;第三台电脑开始工作：&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-comment">//第三台电脑组装</span>    Computer * computer3 = <span class="hljs-keyword">new</span> Computer(<span class="hljs-keyword">new</span> LenovoCPU, <span class="hljs-keyword">new</span> IntelVideoCard, <span class="hljs-keyword">new</span> LenovoMemory);;    computer3-&gt;work();    <span class="hljs-keyword">delete</span> computer3;&#125;</code></pre><h2 id="5-文件操作"><a href="#5-文件操作" class="headerlink" title="5 文件操作"></a>5 文件操作</h2><p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p><p>通过<strong>文件可以将数据持久化</strong></p><p>C++中对文件操作需要包含头文件 ==&lt; fstream &gt;==</p><p>文件类型分为两种：</p><ol><li><strong>文本文件</strong>     -  文件以文本的<strong>ASCII码</strong>形式存储在计算机中</li><li><strong>二进制文件</strong> -  文件以文本的<strong>二进制</strong>形式存储在计算机中，用户一般不能直接读懂它们</li></ol><p>操作文件的三大类:</p><ol><li>ofstream：写操作</li><li>ifstream： 读操作</li><li>fstream ： 读写操作</li></ol><h3 id="5-1文本文件"><a href="#5-1文本文件" class="headerlink" title="5.1文本文件"></a>5.1文本文件</h3><h4 id="5-1-1写文件"><a href="#5-1-1写文件" class="headerlink" title="5.1.1写文件"></a>5.1.1写文件</h4><p>   写文件步骤如下：</p><ol><li><p>包含头文件   </p><p>  #include &lt;fstream&gt;</p></li><li><p>创建流对象  </p><p>ofstream ofs;</p></li><li><p>打开文件</p><p>ofs.open(“文件路径”,打开方式);</p></li><li><p>写数据</p><p>ofs &lt;&lt; “写入的数据”;</p></li><li><p>关闭文件</p><p>ofs.close();</p></li></ol><p>文件打开方式：</p><table><thead><tr><th>打开方式</th><th>解释</th></tr></thead><tbody><tr><td>ios::in</td><td>为读文件而打开文件</td></tr><tr><td>ios::out</td><td>为写文件而打开文件</td></tr><tr><td>ios::ate</td><td>初始位置：文件尾</td></tr><tr><td>ios::app</td><td>追加方式写文件</td></tr><tr><td>ios::trunc</td><td>如果文件存在先删除，再创建</td></tr><tr><td>ios::binary</td><td>二进制方式</td></tr></tbody></table><p><strong>注意：</strong> 文件打开方式可以配合使用，利用|操作符</p><p><strong>例如：</strong>用二进制方式写文件 <code>ios::binary |  ios:: out</code></p><p><strong>示例：</strong></p><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    ofstream ofs;    ofs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>, ios::out);    ofs &lt;&lt; <span class="hljs-string">&quot;姓名：张三&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    ofs &lt;&lt; <span class="hljs-string">&quot;性别：男&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    ofs &lt;&lt; <span class="hljs-string">&quot;年龄：18&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    ofs.<span class="hljs-built_in">close</span>();&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    test01();    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>总结：</p><ul><li>文件操作必须包含头文件 fstream</li><li>读文件可以利用 ofstream  ，或者fstream类</li><li>打开文件时候需要指定操作文件的路径，以及打开方式</li><li>利用&lt;&lt;可以向文件中写数据</li><li>操作完毕，要关闭文件</li></ul><h4 id="5-1-2读文件"><a href="#5-1-2读文件" class="headerlink" title="5.1.2读文件"></a>5.1.2读文件</h4><p>读文件与写文件步骤相似，但是读取方式相对于比较多</p><p>读文件步骤如下：</p><ol><li><p>包含头文件   </p><p>  #include &lt;fstream&gt;</p></li><li><p>创建流对象  </p><p>ifstream ifs;</p></li><li><p>打开文件并判断文件是否打开成功</p><p>ifs.open(“文件路径”,打开方式);</p></li><li><p>读数据</p><p>四种方式读取</p></li><li><p>关闭文件</p><p>ifs.close();</p></li></ol><p><strong>示例：</strong></p><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    ifstream ifs;    ifs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>, ios::in);    <span class="hljs-keyword">if</span> (!ifs.is_open())    &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;文件打开失败&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">//第一种方式</span>    <span class="hljs-comment">//char buf[1024] = &#123; 0 &#125;;</span>    <span class="hljs-comment">//while (ifs &gt;&gt; buf)</span>    <span class="hljs-comment">//&#123;</span>    <span class="hljs-comment">//    cout &lt;&lt; buf &lt;&lt; endl;</span>    <span class="hljs-comment">//&#125;</span>    <span class="hljs-comment">//第二种</span>    <span class="hljs-comment">//char buf[1024] = &#123; 0 &#125;;</span>    <span class="hljs-comment">//while (ifs.getline(buf,sizeof(buf)))</span>    <span class="hljs-comment">//&#123;</span>    <span class="hljs-comment">//    cout &lt;&lt; buf &lt;&lt; endl;</span>    <span class="hljs-comment">//&#125;</span>    <span class="hljs-comment">//第三种</span>    <span class="hljs-comment">//string buf;</span>    <span class="hljs-comment">//while (getline(ifs, buf))</span>    <span class="hljs-comment">//&#123;</span>    <span class="hljs-comment">//    cout &lt;&lt; buf &lt;&lt; endl;</span>    <span class="hljs-comment">//&#125;</span>    <span class="hljs-keyword">char</span> c;    <span class="hljs-keyword">while</span> ((c = ifs.<span class="hljs-built_in">get</span>()) != EOF)    &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; c;    &#125;    ifs.<span class="hljs-built_in">close</span>();&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    test01();    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>总结：</p><ul><li>读文件可以利用 ifstream  ，或者fstream类</li><li>利用is_open函数可以判断文件是否打开成功</li><li>close 关闭文件 </li></ul><h3 id="5-2-二进制文件"><a href="#5-2-二进制文件" class="headerlink" title="5.2 二进制文件"></a>5.2 二进制文件</h3><p>以二进制的方式对文件进行读写操作</p><p>打开方式要指定为 ==ios::binary==</p><h4 id="5-2-1-写文件"><a href="#5-2-1-写文件" class="headerlink" title="5.2.1 写文件"></a>5.2.1 写文件</h4><p>二进制方式写文件主要利用流对象调用成员函数write</p><p>函数原型 ：<code>ostream&amp; write(const char * buffer,int len);</code></p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><p><strong>示例：</strong></p><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">char</span> m_Name[<span class="hljs-number">64</span>];    <span class="hljs-keyword">int</span> m_Age;&#125;;<span class="hljs-comment">//二进制文件  写文件</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//1、包含头文件</span>    <span class="hljs-comment">//2、创建输出流对象</span>    <span class="hljs-function">ofstream <span class="hljs-title">ofs</span><span class="hljs-params">(<span class="hljs-string">&quot;person.txt&quot;</span>, ios::out | ios::binary)</span></span>;    <span class="hljs-comment">//3、打开文件</span>    <span class="hljs-comment">//ofs.open(&quot;person.txt&quot;, ios::out | ios::binary);</span>    Person p = &#123;<span class="hljs-string">&quot;张三&quot;</span>  , <span class="hljs-number">18</span>&#125;;    <span class="hljs-comment">//4、写文件</span>    ofs.<span class="hljs-built_in">write</span>((<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *)&amp;p, <span class="hljs-keyword">sizeof</span>(p));    <span class="hljs-comment">//5、关闭文件</span>    ofs.<span class="hljs-built_in">close</span>();&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    test01();    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>总结：</p><ul><li>文件输出流对象 可以通过write函数，以二进制方式写数据</li></ul><h4 id="5-2-2-读文件"><a href="#5-2-2-读文件" class="headerlink" title="5.2.2 读文件"></a>5.2.2 读文件</h4><p>二进制方式读文件主要利用流对象调用成员函数read</p><p>函数原型：<code>istream&amp; read(char *buffer,int len);</code></p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><p>示例：</p><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">char</span> m_Name[<span class="hljs-number">64</span>];    <span class="hljs-keyword">int</span> m_Age;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-function">ifstream <span class="hljs-title">ifs</span><span class="hljs-params">(<span class="hljs-string">&quot;person.txt&quot;</span>, ios::in | ios::binary)</span></span>;    <span class="hljs-keyword">if</span> (!ifs.is_open())    &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;文件打开失败&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    Person p;    ifs.<span class="hljs-built_in">read</span>((<span class="hljs-keyword">char</span> *)&amp;p, <span class="hljs-keyword">sizeof</span>(p));    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="hljs-string">&quot; 年龄： &quot;</span> &lt;&lt; p.m_Age &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    test01();    system(<span class="hljs-string">&quot;pause&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><ul><li>文件输入流对象 可以通过read函数，以二进制方式读数据</li></ul>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>numpy</title>
    <link href="/2021/03/31/numpy/"/>
    <url>/2021/03/31/numpy/</url>
    
    <content type="html"><![CDATA[<h2 id="数组构造"><a href="#数组构造" class="headerlink" title="数组构造"></a>数组构造</h2><h3 id="特殊矩阵"><a href="#特殊矩阵" class="headerlink" title="特殊矩阵"></a>特殊矩阵</h3><pre><code class="hljs python">In [<span class="hljs-number">31</span>]: np.linspace(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">11</span>) <span class="hljs-comment"># 起始、终止（包含）、样本个数 </span>Out[<span class="hljs-number">31</span>]: array([<span class="hljs-number">1.</span> , <span class="hljs-number">1.4</span>, <span class="hljs-number">1.8</span>, <span class="hljs-number">2.2</span>, <span class="hljs-number">2.6</span>, <span class="hljs-number">3.</span> , <span class="hljs-number">3.4</span>, <span class="hljs-number">3.8</span>, <span class="hljs-number">4.2</span>, <span class="hljs-number">4.6</span>, <span class="hljs-number">5.</span> ])In [<span class="hljs-number">32</span>]: np.arange(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>) <span class="hljs-comment"># 起始、终止（不包含）、步长 </span>Out[<span class="hljs-number">32</span>]: array([<span class="hljs-number">1</span>, <span class="hljs-number">3</span>])In [<span class="hljs-number">33</span>]: np.zeros((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)) <span class="hljs-comment"># 传入元组表示各维度大小 </span>Out[<span class="hljs-number">33</span>]: array([[<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>], [<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>]])In [<span class="hljs-number">34</span>]: np.eye(<span class="hljs-number">3</span>) <span class="hljs-comment"># 3*3 的单位矩阵</span>Out[<span class="hljs-number">34</span>]: array([[<span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>], [<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>], [<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>]])In [<span class="hljs-number">35</span>]: np.eye(<span class="hljs-number">3</span>, k=<span class="hljs-number">1</span>) <span class="hljs-comment"># 偏移主对角线 1 个单位的伪单位矩阵 </span>Out[<span class="hljs-number">35</span>]: array([[<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>], [<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>], [<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>]])In [<span class="hljs-number">36</span>]: np.full((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>), <span class="hljs-number">10</span>) <span class="hljs-comment"># 元组传入大小，10 表示填充数值 </span>Out[<span class="hljs-number">36</span>]: array([[<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>], [<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>]])In [<span class="hljs-number">37</span>]: np.full((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>), [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]) <span class="hljs-comment"># 通过传入列表填充每列的值 </span>Out[<span class="hljs-number">37</span>]: array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]])</code></pre><h3 id="随机矩阵"><a href="#随机矩阵" class="headerlink" title="随机矩阵"></a>随机矩阵</h3><p>随机矩阵：np.random 最常用的随机生成函数为 rand, randn, randint, choice ，它们分别表示 0-1 均匀分布的随机数组、标准正态 的随机数组、随机整数组和随机列表抽样：</p><p>对于服从区间 a 到 b 上的均匀分布可以如下生成：</p><pre><code class="hljs python">a, b = <span class="hljs-number">5</span>, <span class="hljs-number">15</span>(b - a) * np.random.rand(<span class="hljs-number">3</span>) + a</code></pre><p> array([ 7.81852712, 13.73446249, 9.55726572])</p><p>randn 生成了 N(0,I) 的标准正态分布：</p><pre><code class="hljs apache"><span class="hljs-attribute">np</span>.random.randn(<span class="hljs-number">3</span>)<span class="hljs-attribute">array</span>([-<span class="hljs-number">0</span>.<span class="hljs-number">66241809</span>, -<span class="hljs-number">0</span>.<span class="hljs-number">43323251</span>, -<span class="hljs-number">0</span>.<span class="hljs-number">2569318</span> ])</code></pre><p>对于服从方差为 σ2 均值为 µ 的一元正态分布可以如下生成：</p><pre><code class="hljs python">sigma, mu = <span class="hljs-number">2.5</span>, <span class="hljs-number">3</span>mu + np.random.randn(<span class="hljs-number">3</span>) * sigma Out[<span class="hljs-number">45</span>]: array([<span class="hljs-number">3.35284376</span>, <span class="hljs-number">0.04422116</span>, <span class="hljs-number">3.50676044</span></code></pre><p>randint 可以指定生成随机整数的最小值最大值和维度大小：</p><pre><code class="hljs python">low, high, size = <span class="hljs-number">5</span>, <span class="hljs-number">15</span>, (<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)np.random.randint(low, high, size) Out[<span class="hljs-number">47</span>]: array([[<span class="hljs-number">12</span>, <span class="hljs-number">14</span>], [ <span class="hljs-number">6</span>, <span class="hljs-number">13</span>]])</code></pre><p>choice 可以从给定的列表中，以一定概率和方式抽取结果，当不指定概率时为均匀采样，默认抽取方式为有 放回抽样：</p><pre><code class="hljs python">my_list = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>]np.random.choice(my_list, <span class="hljs-number">2</span>, replace=<span class="hljs-literal">False</span>, p=[<span class="hljs-number">0.1</span>, <span class="hljs-number">0.7</span>, <span class="hljs-number">0.1</span> ,<span class="hljs-number">0.1</span>]) Out[<span class="hljs-number">49</span>]: array([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>], dtype=<span class="hljs-string">&#x27;&lt;U1&#x27;</span>)</code></pre><pre><code class="hljs prolog">np.random.choice(my_list, (<span class="hljs-number">3</span>,<span class="hljs-number">3</span>)) <span class="hljs-symbol">Out</span>[<span class="hljs-number">50</span>]: array([[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>], [<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>], [<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]], dtype=<span class="hljs-string">&#x27;&lt;U1&#x27;</span>)</code></pre><p> 可以看到当返回的元素个数与原列表相同时，等价于使用 permutation 函数，即打散原列表：</p><pre><code class="hljs python">np.random.permutation(my_list) Out[<span class="hljs-number">51</span>]: array([<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>], dtype=<span class="hljs-string">&#x27;&lt;U1&#x27;</span>)</code></pre><h2 id="np-数组的变形与合并"><a href="#np-数组的变形与合并" class="headerlink" title="np 数组的变形与合并"></a>np 数组的变形与合并</h2><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>合并操作：r_, c_ 对于二维数组而言，r_ 和 c_ 分别表示上下合并和左右合并：</p><pre><code class="hljs python">np.r_[np.zeros((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)),np.zeros((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))Out[<span class="hljs-number">57</span>]: array([[<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>], [<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>], [<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>], [<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>]])</code></pre><pre><code class="hljs angelscript">np.c_[np.zeros((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)),np.zeros((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))] Out[<span class="hljs-number">58</span>]: <span class="hljs-built_in">array</span>([[<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>], [<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>]])</code></pre><h3 id="维度变换-reshape"><a href="#维度变换-reshape" class="headerlink" title="维度变换 reshape"></a>维度变换 reshape</h3><p>reshape 能够帮助用户把原数组按照新的维度重新排列。在使用时有两种模式，分别为 <strong>C 模式</strong>和 <strong>F 模式</strong>，分 别以逐行和逐列的顺序进行填充读取。</p><pre><code class="hljs angelscript">target = np.arange(<span class="hljs-number">8</span>).reshape(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>)Out[<span class="hljs-number">64</span>]: <span class="hljs-built_in">array</span>([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]])</code></pre><pre><code class="hljs angelscript">target.reshape((<span class="hljs-number">4</span>,<span class="hljs-number">2</span>), order=<span class="hljs-string">&#x27;C&#x27;</span>) # 按照行读取和填充 Out[<span class="hljs-number">65</span>]: <span class="hljs-built_in">array</span>([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>],[<span class="hljs-number">6</span>, <span class="hljs-number">7</span>]])</code></pre><pre><code class="hljs angelscript">target.reshape((<span class="hljs-number">4</span>,<span class="hljs-number">2</span>), order=<span class="hljs-string">&#x27;F&#x27;</span>) # 按照列读取和填充 Out[<span class="hljs-number">66</span>]: <span class="hljs-built_in">array</span>([[<span class="hljs-number">0</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">7</span>]])</code></pre><p>特别地，由于被调用数组的大小是确定的，reshape 允许有一个维度存在空缺，此时只需填充-1 即可：</p><pre><code class="hljs angelscript">target.reshape((<span class="hljs-number">4</span>,<span class="hljs-number">-1</span>)) <span class="hljs-built_in">array</span>([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>], [<span class="hljs-number">6</span>, <span class="hljs-number">7</span>]])</code></pre><p>下面将 n*1 大小的数组转为 1 维数组的操作是经常使用的：</p><pre><code class="hljs angelscript">In [<span class="hljs-number">68</span>]: target = np.ones((<span class="hljs-number">3</span>,<span class="hljs-number">1</span>))In [<span class="hljs-number">69</span>]: target Out[<span class="hljs-number">69</span>]: <span class="hljs-built_in">array</span>([[<span class="hljs-number">1.</span>], [<span class="hljs-number">1.</span>], [<span class="hljs-number">1.</span>]])In [<span class="hljs-number">70</span>]: target.reshape(<span class="hljs-number">-1</span>) Out[<span class="hljs-number">70</span>]: <span class="hljs-built_in">array</span>([<span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>])</code></pre><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><p>where 是一种条件函数，可以指定满足条件与不满足条件位置对应的填充值</p><pre><code class="hljs python">a = np.array([<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>])np.where(a&gt;<span class="hljs-number">0</span>, a, <span class="hljs-number">5</span>) <span class="hljs-comment"># 对应位置为 True 时填充 a 对应元素，否则填充 </span>Out[<span class="hljs-number">79</span>]: array([<span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>])</code></pre><h3 id="nonzero-argmax-argmin"><a href="#nonzero-argmax-argmin" class="headerlink" title="nonzero, argmax, argmin"></a>nonzero, argmax, argmin</h3><p>这三个函数返回的都是索引，nonzero 返回非零数的索引，argmax, argmin 分别返回最大和最小数的索引：</p><pre><code class="hljs python">In [<span class="hljs-number">80</span>]: a = np.array([<span class="hljs-number">-2</span>,<span class="hljs-number">-5</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">-1</span>])In [<span class="hljs-number">81</span>]: np.nonzero(a) Out[<span class="hljs-number">81</span>]: (array([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>], dtype=int64),)In [<span class="hljs-number">82</span>]: a.argmax() Out[<span class="hljs-number">82</span>]: <span class="hljs-number">4</span>In [<span class="hljs-number">83</span>]: a.argmin() Out[<span class="hljs-number">83</span>]: <span class="hljs-number">1</span></code></pre><h3 id="cumprod-cumsum-diff"><a href="#cumprod-cumsum-diff" class="headerlink" title="cumprod, cumsum, diff"></a>cumprod, cumsum, diff</h3><p>cumprod, cumsum 分别表示累乘和累加函数，返回同长度的数组，diff 表示和前一个元素做差，由于第一个 元素为缺失值，因此在默认参数情况下，返回长度是原数组减 1</p><pre><code class="hljs PYTHON">In [<span class="hljs-number">87</span>]: a = np.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])In [<span class="hljs-number">88</span>]: a.cumprod() Out[<span class="hljs-number">88</span>]: array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>], dtype=int32)In [<span class="hljs-number">89</span>]: a.cumsum() Out[<span class="hljs-number">89</span>]: array([<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>], dtype=int32)In [<span class="hljs-number">90</span>]: np.diff(a) Out[<span class="hljs-number">90</span>]: array([<span class="hljs-number">1</span>, <span class="hljs-number">1</span>])</code></pre><h3 id="统计函数"><a href="#统计函数" class="headerlink" title="统计函数"></a>统计函数</h3><p>常用的统计函数包括 max, min, mean, median, std, var, sum, quantile ，其中分位数计算是全局方法，因此 不能通过 array.quantile 的方法调用：</p><pre><code class="hljs angelscript">In [<span class="hljs-number">91</span>]: target = np.arange(<span class="hljs-number">5</span>)In [<span class="hljs-number">92</span>]: target Out[<span class="hljs-number">92</span>]: <span class="hljs-built_in">array</span>([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])In [<span class="hljs-number">93</span>]: target.max() Out[<span class="hljs-number">93</span>]: <span class="hljs-number">4</span>In [<span class="hljs-number">94</span>]: np.quantile(target, <span class="hljs-number">0.5</span>) # <span class="hljs-number">0.5</span> 分位数 Out[<span class="hljs-number">94</span>]: <span class="hljs-number">2.0</span></code></pre><p>但是对于含有缺失值的数组，它们返回的结果也是缺失值，如果需要略过缺失值，必须使用 nan* 类型的函 数，上述的几个统计函数都有对应的 nan* 函数</p><pre><code class="hljs angelscript">In [<span class="hljs-number">95</span>]: target = np.<span class="hljs-built_in">array</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, np.nan])In [<span class="hljs-number">96</span>]: target Out[<span class="hljs-number">96</span>]: <span class="hljs-built_in">array</span>([ <span class="hljs-number">1.</span>, <span class="hljs-number">2.</span>, nan])In [<span class="hljs-number">97</span>]: target.max() Out[<span class="hljs-number">97</span>]: nanIn [<span class="hljs-number">98</span>]: np.nanmax(target) Out[<span class="hljs-number">98</span>]: <span class="hljs-number">2.0</span>In [<span class="hljs-number">99</span>]: np.nanquantile(target, <span class="hljs-number">0.5</span>) Out[<span class="hljs-number">99</span>]: <span class="hljs-number">1.5</span></code></pre><p>对于协方差和相关系数分别可以利用 cov, corrcoef 如下计算</p><pre><code class="hljs angelscript">In [<span class="hljs-number">100</span>]: target1 = np.<span class="hljs-built_in">array</span>([<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>])In [<span class="hljs-number">101</span>]: target2 = np.<span class="hljs-built_in">array</span>([<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">-9</span>])In [<span class="hljs-number">102</span>]: np.cov(target1, target2)Out[<span class="hljs-number">102</span>]:<span class="hljs-built_in">array</span>([[ <span class="hljs-number">11.66666667</span>, <span class="hljs-number">-16.66666667</span>],[<span class="hljs-number">-16.66666667</span>, <span class="hljs-number">38.66666667</span>]])In [<span class="hljs-number">103</span>]: np.corrcoef(target1, target2)Out[<span class="hljs-number">103</span>]:<span class="hljs-built_in">array</span>([[ <span class="hljs-number">1.</span> , <span class="hljs-number">-0.78470603</span>],[<span class="hljs-number">-0.78470603</span>, <span class="hljs-number">1.</span> ]])</code></pre><h3 id="向量范数和矩阵范数：np-linalg-norm"><a href="#向量范数和矩阵范数：np-linalg-norm" class="headerlink" title="向量范数和矩阵范数：np.linalg.norm"></a>向量范数和矩阵范数：np.linalg.norm</h3><h3 id="矩阵乘法："><a href="#矩阵乘法：" class="headerlink" title="矩阵乘法：@"></a>矩阵乘法：@</h3><pre><code class="hljs python">In [<span class="hljs-number">133</span>]: a = np.arange(<span class="hljs-number">4</span>).reshape(<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>)In [<span class="hljs-number">134</span>]: aOut[<span class="hljs-number">134</span>]:array([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>],[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]])In [<span class="hljs-number">135</span>]: b = np.arange(<span class="hljs-number">-4</span>,<span class="hljs-number">0</span>).reshape(<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>)In [<span class="hljs-number">136</span>]: bOut[<span class="hljs-number">136</span>]:array([[<span class="hljs-number">-4</span>, <span class="hljs-number">-3</span>],[<span class="hljs-number">-2</span>, <span class="hljs-number">-1</span>]])In [<span class="hljs-number">137</span>]: a@bOut[<span class="hljs-number">137</span>]:array([[ <span class="hljs-number">-2</span>, <span class="hljs-number">-1</span>],[<span class="hljs-number">-14</span>, <span class="hljs-number">-9</span>]])</code></pre><h2 id="广播机制"><a href="#广播机制" class="headerlink" title="广播机制"></a>广播机制</h2><p>广播机制用于处理两个不同维度数组之间的操作，这里只讨论不超过两维的数组广播机制</p><h3 id="标量和数组的操作"><a href="#标量和数组的操作" class="headerlink" title="标量和数组的操作"></a>标量和数组的操作</h3><p>当一个标量和数组进行运算时，标量会自动把大小扩充为数组大小，之后进行逐元素操作：</p><pre><code class="hljs python">In [<span class="hljs-number">108</span>]: res = <span class="hljs-number">3</span> * np.ones((<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)) + <span class="hljs-number">1</span>In [<span class="hljs-number">109</span>]: res Out[<span class="hljs-number">109</span>]: array([[<span class="hljs-number">4.</span>, <span class="hljs-number">4.</span>], [<span class="hljs-number">4.</span>, <span class="hljs-number">4.</span>]])In [<span class="hljs-number">110</span>]: res = <span class="hljs-number">1</span> / resIn [<span class="hljs-number">111</span>]: res Out[<span class="hljs-number">111</span>]: array([[<span class="hljs-number">0.25</span>, <span class="hljs-number">0.25</span>], [<span class="hljs-number">0.25</span>, <span class="hljs-number">0.25</span>]])</code></pre><h3 id="二维数组之间的操作"><a href="#二维数组之间的操作" class="headerlink" title="二维数组之间的操作"></a>二维数组之间的操作</h3><p>当两个数组维度完全一致时，使用对应元素的操作，否则会报错，除非其中的某个数组的维度是 m×1 或者 1×n ，那么会扩充其具有 1 的维度为另一个数组对应维度的大小。例如，1×2 数组和 3×2 数组做逐元素 运算时会把第一个数组扩充为 3×2 ，扩充时的对应数值进行赋值。但是，需要注意的是，如果第一个数组 的维度是 1×3 ，那么由于在第二维上的大小不匹配且不为 1 ，此时报错。</p><pre><code class="hljs python">In [<span class="hljs-number">112</span>]: res = np.ones((<span class="hljs-number">3</span>,<span class="hljs-number">2</span>))In [<span class="hljs-number">113</span>]: res Out[<span class="hljs-number">113</span>]: array([[<span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>], [<span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>], [<span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>]])In [<span class="hljs-number">114</span>]: res * np.array([[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]]) <span class="hljs-comment"># 扩充第一维度为 3 </span>Out[<span class="hljs-number">114</span>]: array([[<span class="hljs-number">2.</span>, <span class="hljs-number">3.</span>], [<span class="hljs-number">2.</span>, <span class="hljs-number">3.</span>], [<span class="hljs-number">2.</span>, <span class="hljs-number">3.</span>]])In [<span class="hljs-number">115</span>]: res * np.array([[<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>]]) <span class="hljs-comment"># 扩充第二维度为 2 </span>Out[<span class="hljs-number">115</span>]: array([[<span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>], [<span class="hljs-number">3.</span>, <span class="hljs-number">3.</span>], [<span class="hljs-number">4.</span>, <span class="hljs-number">4.</span>]])In [<span class="hljs-number">116</span>]: res * np.array([[<span class="hljs-number">2</span>]]) <span class="hljs-comment"># 等价于两次扩充 </span>Out[<span class="hljs-number">116</span>]: array([[<span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>], [<span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>], [<span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>]])</code></pre><h3 id="一维数组与二维数组的操作"><a href="#一维数组与二维数组的操作" class="headerlink" title="一维数组与二维数组的操作"></a>一维数组与二维数组的操作</h3><p>当一维数组 Ak 与二维数组 Bm,n 操作时，等价于把一维数组视作 A1,k 的二维数组，使用的广播法则与【b】 中一致，当 k! = n 且 k,n 都不是 1 时报错。</p><pre><code class="hljs python">In [<span class="hljs-number">117</span>]: np.ones(<span class="hljs-number">3</span>) + np.ones((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)) Out[<span class="hljs-number">117</span>]: array([[<span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>], [<span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>]])In [<span class="hljs-number">118</span>]: np.ones(<span class="hljs-number">3</span>) + np.ones((<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)) Out[<span class="hljs-number">118</span>]: array([[<span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>], [<span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>]])In [<span class="hljs-number">119</span>]: np.ones(<span class="hljs-number">1</span>) + np.ones((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)) Out[<span class="hljs-number">119</span>]: array([[<span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>], [<span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>]])</code></pre><h3 id="一维数组和一维数组操作"><a href="#一维数组和一维数组操作" class="headerlink" title="一维数组和一维数组操作"></a>一维数组和一维数组操作</h3><p>矩阵A的行乘以矩阵B的列，</p><pre><code class="hljs angelscript">arr1 = np.full((<span class="hljs-number">1</span>,<span class="hljs-number">3</span>), <span class="hljs-number">4</span>)arr2 = np.full((<span class="hljs-number">4</span>,<span class="hljs-number">1</span>), <span class="hljs-number">3</span>)arr1*arr2# output<span class="hljs-built_in">array</span>([[<span class="hljs-number">12</span>, <span class="hljs-number">12</span>, <span class="hljs-number">12</span>, <span class="hljs-number">12</span>],       [<span class="hljs-number">12</span>, <span class="hljs-number">12</span>, <span class="hljs-number">12</span>, <span class="hljs-number">12</span>],       [<span class="hljs-number">12</span>, <span class="hljs-number">12</span>, <span class="hljs-number">12</span>, <span class="hljs-number">12</span>],       [<span class="hljs-number">12</span>, <span class="hljs-number">12</span>, <span class="hljs-number">12</span>, <span class="hljs-number">12</span>]])</code></pre>]]></content>
    
    
    <categories>
      
      <category>data science</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>pandas</title>
    <link href="/2021/03/31/pandas/"/>
    <url>/2021/03/31/pandas/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>decision_tree</title>
    <link href="/2021/03/26/decision-tree/"/>
    <url>/2021/03/26/decision-tree/</url>
    
    <content type="html"><![CDATA[<h2 id="Pros-and-Cons"><a href="#Pros-and-Cons" class="headerlink" title="Pros and Cons"></a>Pros and Cons</h2><p>Pros</p><ul><li>非黑盒 </li><li>轻松去除无关Attribute （Gain = 0） </li><li>Test起来很快 （O(depth)）</li></ul><p>Cons</p><ul><li>只能线性分割数据</li><li>贪婪算法（可能找不到最好的树)</li></ul><h2 id="信息熵、信息增益、信息增益率"><a href="#信息熵、信息增益、信息增益率" class="headerlink" title="信息熵、信息增益、信息增益率"></a>信息熵、信息增益、信息增益率</h2><h3 id="信息熵"><a href="#信息熵" class="headerlink" title="信息熵"></a>信息熵</h3><p>信息熵是用来评估样本集合的纯度的一个参数，就是说，给出一个样本集合，这个样本集合中的样本可能属于好多不同的类别，也可能只属于一个类别，那么如果属于好多不同的类别的话，我们就说这个样本是不纯的，如果只属于一个类别，那么，我们就说这个样本是纯洁的。<br>　　而信息熵这个东西就是来计算一个样本集合中的数据是纯洁的还是不纯洁的。下面上公式：<br>$$<br>Ent(D)=−∑_{k=1}^{y}p_klog_2p_k<br>$$<br>下面解释一下公式的意思，其实很好理解，计算一个集合的纯度，就是把集合中每一个类别所占的比例p k p_k<em>p**k</em>（k从1到 ∣ y ∣ \left | y \right |∣<em>y</em>∣，其中 ∣ y ∣ \left | y \right |∣<em>y</em>∣ 表示类别的个数）乘上它的对数，然后加到一起，然后经过计算之后，可以得到一个数据集的信息熵，然后根据信息熵，可以判断这个数据集是否纯粹。信息熵越小的话，表明这个数据集越纯粹。信息熵的最小值为0，此时数据集D中只含有一个类别。</p>]]></content>
    
    
    
    <tags>
      
      <tag>machine learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue</title>
    <link href="/2021/02/28/vue/"/>
    <url>/2021/02/28/vue/</url>
    
    <content type="html"><![CDATA[<h2 id="解决跨域问题"><a href="#解决跨域问题" class="headerlink" title="解决跨域问题"></a>解决跨域问题</h2><h3 id="开发时"><a href="#开发时" class="headerlink" title="开发时"></a>开发时</h3><p>在<code>vue.config.js</code>中添加devServer</p><pre><code class="hljs js">devServer:&#123;        port: <span class="hljs-number">8888</span>,        host: <span class="hljs-string">&#x27;localhost&#x27;</span>,        https: <span class="hljs-literal">false</span>,        open: <span class="hljs-literal">true</span>,        proxy:&#123;        <span class="hljs-string">&#x27;/dev&#x27;</span>: &#123;                target: <span class="hljs-string">&quot;http://58.87.111.39:9999&quot;</span>,                changeOrigin: <span class="hljs-literal">true</span>,                pathRewrite:&#123;                    <span class="hljs-string">&#x27;^/dev&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>,                &#125;            &#125;        &#125;</code></pre><h3 id="生产时"><a href="#生产时" class="headerlink" title="生产时"></a>生产时</h3><p>在<code>nginx</code>中设置<code>proxy_pass</code></p><pre><code class="hljs config">location &#x2F;dev&#x2F; &#123;                proxy_pass http:&#x2F;&#x2F;58.87.111.39:9999&#x2F;;        &#125;</code></pre><h3 id="构建（build）环节"><a href="#构建（build）环节" class="headerlink" title="构建（build）环节"></a>构建（build）环节</h3><p>加上publicPath: ‘./‘</p><pre><code class="hljs js">devServer:&#123;        port: <span class="hljs-number">8888</span>,        publicPath: <span class="hljs-string">&#x27;./&#x27;</span>,        host: <span class="hljs-string">&#x27;localhost&#x27;</span>,        https: <span class="hljs-literal">false</span>,        open: <span class="hljs-literal">true</span>,        proxy:&#123;        <span class="hljs-string">&#x27;/dev&#x27;</span>: &#123;                target: <span class="hljs-string">&quot;http://58.87.111.39:9999&quot;</span>,                changeOrigin: <span class="hljs-literal">true</span>,                pathRewrite:&#123;                    <span class="hljs-string">&#x27;^/dev&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>,                &#125;            &#125;        &#125;</code></pre><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vim</title>
    <link href="/2020/12/13/vim/"/>
    <url>/2020/12/13/vim/</url>
    
    <content type="html"><![CDATA[<h2 id="Shortcut-keys"><a href="#Shortcut-keys" class="headerlink" title="Shortcut keys"></a>Shortcut keys</h2><table><thead><tr><th align="left">Shortcut Keys</th><th align="left">Function</th></tr></thead><tbody><tr><td align="left">Main</td><td align="left"></td></tr><tr><td align="left">Escape key</td><td align="left">Gets out of the current mode into the “command mode”. All keys are bound of commands.</td></tr><tr><td align="left">i</td><td align="left">“Insert mode” for inserting text. Keys behave as expected.</td></tr><tr><td align="left">:</td><td align="left">“Last-line mode” where Vim expects you to enter a command such as to save the document.</td></tr><tr><td align="left">:ter[minal]</td><td align="left">Open a terminal window</td></tr><tr><td align="left">Navigation keys</td><td align="left"></td></tr><tr><td align="left">h</td><td align="left">moves the cursor one character to the left.</td></tr><tr><td align="left">j or Ctrl + J</td><td align="left">moves the cursor down one line.</td></tr><tr><td align="left">k or Ctrl + P</td><td align="left">moves the cursor up one line.</td></tr><tr><td align="left">l</td><td align="left">moves the cursor one character to the right.</td></tr><tr><td align="left">0</td><td align="left">moves the cursor to the beginning of the line.</td></tr><tr><td align="left">$</td><td align="left">moves the cursor to the end of the line.</td></tr><tr><td align="left">^</td><td align="left">moves the cursor to the first non-empty character of the line</td></tr><tr><td align="left">w</td><td align="left">move forward one word (next alphanumeric word)</td></tr><tr><td align="left">W</td><td align="left">move forward one word (delimited by a white space)</td></tr><tr><td align="left">5w</td><td align="left">move forward five words</td></tr><tr><td align="left">b</td><td align="left">move backward one word (previous alphanumeric word)</td></tr><tr><td align="left">B</td><td align="left">move backward one word (delimited by a white space)</td></tr><tr><td align="left">5b</td><td align="left">move backward five words</td></tr><tr><td align="left">G</td><td align="left">move to the end of the file</td></tr><tr><td align="left">gg</td><td align="left">move to the beginning of the file.</td></tr><tr><td align="left"></td><td align="left"></td></tr><tr><td align="left">Navigate around the document</td><td align="left"></td></tr><tr><td align="left">(</td><td align="left">jumps to the previous sentence</td></tr><tr><td align="left">)</td><td align="left">jumps to the next sentence</td></tr><tr><td align="left">{</td><td align="left">jumps to the previous paragraph</td></tr><tr><td align="left">}</td><td align="left">jumps to the next paragraph</td></tr><tr><td align="left">[[</td><td align="left">jumps to the previous section</td></tr><tr><td align="left">]]</td><td align="left">jumps to the next section</td></tr><tr><td align="left">[]</td><td align="left">jump to the end of the previous section</td></tr><tr><td align="left">][</td><td align="left">jump to the end of the next section</td></tr><tr><td align="left"></td><td align="left"></td></tr><tr><td align="left">Insert text</td><td align="left"></td></tr><tr><td align="left">a</td><td align="left">Insert text after the cursor</td></tr><tr><td align="left">A</td><td align="left">Insert text at the end of the line</td></tr><tr><td align="left">i</td><td align="left">Insert text before the cursor</td></tr><tr><td align="left">o</td><td align="left">Begin a new line below the cursor</td></tr><tr><td align="left">O</td><td align="left">Begin a new line above the cursor</td></tr><tr><td align="left"></td><td align="left"></td></tr><tr><td align="left">Special inserts</td><td align="left"></td></tr><tr><td align="left">:r [filename]</td><td align="left">Insert the file [filename] below the cursor</td></tr><tr><td align="left">:r ![command]</td><td align="left">Execute [command] and insert its output below the cursor</td></tr><tr><td align="left"></td><td align="left"></td></tr><tr><td align="left">Delete text</td><td align="left"></td></tr><tr><td align="left">x</td><td align="left">delete character at cursor</td></tr><tr><td align="left">dw</td><td align="left">delete a word.</td></tr><tr><td align="left">d0</td><td align="left">delete to the beginning of a line.</td></tr><tr><td align="left">d$</td><td align="left">delete to the end of a line.</td></tr><tr><td align="left">d)</td><td align="left">delete to the end of sentence.</td></tr><tr><td align="left">dgg</td><td align="left">delete to the beginning of the file.</td></tr><tr><td align="left">dG</td><td align="left">delete to the end of the file.</td></tr><tr><td align="left">dd</td><td align="left">delete line</td></tr><tr><td align="left">3dd</td><td align="left">delete three lines</td></tr><tr><td align="left"></td><td align="left"></td></tr><tr><td align="left">Simple replace text</td><td align="left"></td></tr><tr><td align="left">r{text}</td><td align="left">Replace the character under the cursor with {text}</td></tr><tr><td align="left">R</td><td align="left">Replace characters instead of inserting them</td></tr><tr><td align="left"></td><td align="left"></td></tr><tr><td align="left">Copy/Paste text</td><td align="left"></td></tr><tr><td align="left">yy</td><td align="left">copy current line into storage buffer</td></tr><tr><td align="left">[“x]yy</td><td align="left">Copy the current lines into register x</td></tr><tr><td align="left">p</td><td align="left">paste storage buffer after current line</td></tr><tr><td align="left">P</td><td align="left">paste storage buffer before current line</td></tr><tr><td align="left">[“x]p</td><td align="left">paste from register x after current line</td></tr><tr><td align="left">[“x]P</td><td align="left">paste from register x before current line</td></tr><tr><td align="left"></td><td align="left"></td></tr><tr><td align="left">Undo/Redo operation</td><td align="left"></td></tr><tr><td align="left">u</td><td align="left">undo the last operation.</td></tr><tr><td align="left">Ctrl+r</td><td align="left">redo the last undo.</td></tr><tr><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"></td></tr><tr><td align="left">f or F</td><td align="left">Search for the next occurrence of a character or go to the previous occurrence</td></tr><tr><td align="left">Bookmarks</td><td align="left"></td></tr><tr><td align="left">m {a-z A-Z}</td><td align="left">Set bookmark {a-z A-Z} at the current cursor position</td></tr><tr><td align="left">:marks</td><td align="left">List all bookmarks</td></tr><tr><td align="left">`{a-z A-Z}</td><td align="left">Jumps to the bookmark {a-z A-Z}</td></tr><tr><td align="left"></td><td align="left"></td></tr><tr><td align="left">Select text</td><td align="left"></td></tr><tr><td align="left">v</td><td align="left">Enter visual mode per character</td></tr><tr><td align="left">V</td><td align="left">Enter visual mode per line</td></tr><tr><td align="left">Esc</td><td align="left">Exit visual mode</td></tr><tr><td align="left"></td><td align="left"></td></tr><tr><td align="left">Modify selected text</td><td align="left"></td></tr><tr><td align="left">~</td><td align="left">Switch case</td></tr><tr><td align="left">d</td><td align="left">delete a word.</td></tr><tr><td align="left">c</td><td align="left">change</td></tr><tr><td align="left">y</td><td align="left">yank</td></tr><tr><td align="left">&gt;</td><td align="left">shift right</td></tr><tr><td align="left">&lt;</td><td align="left">shift left</td></tr><tr><td align="left">!</td><td align="left">filter through an external command</td></tr><tr><td align="left"></td><td align="left"></td></tr><tr><td align="left">Save and quit</td><td align="left"></td></tr><tr><td align="left">:q</td><td align="left">Quits Vim but fails when file has been changed</td></tr><tr><td align="left">:w</td><td align="left">Save the file</td></tr><tr><td align="left">:w new_name</td><td align="left">Save the file with the new_name filename</td></tr><tr><td align="left">:wq</td><td align="left">Save the file and quit Vim.</td></tr><tr><td align="left">:q!</td><td align="left">Quit Vim without saving the changes to the file.</td></tr><tr><td align="left">ZZ</td><td align="left">Write file, if modified, and quit Vim</td></tr><tr><td align="left">ZQ</td><td align="left">Same as :q! Quits Vim without writing changes</td></tr><tr><td align="left">:sav[eas] file</td><td align="left">Save file as</td></tr><tr><td align="left">:clo[se]</td><td align="left">Close the current pane</td></tr></tbody></table><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><pre><code class="hljs pgsql">C-ws     Split <span class="hljs-keyword">current</span> <span class="hljs-keyword">window</span> horizontally (alternative :split)C-wv     Split <span class="hljs-keyword">current</span> <span class="hljs-keyword">window</span> vertically (alternative :vsplit)C-ww     Jump <span class="hljs-keyword">to</span> the next <span class="hljs-keyword">window</span>C-wARROW Jump <span class="hljs-keyword">to</span> <span class="hljs-keyword">window</span> left/right/top/bottom (arrow keys) <span class="hljs-keyword">to</span> the <span class="hljs-keyword">current</span>C-w#&lt;    Shrink/resize <span class="hljs-keyword">current</span> <span class="hljs-keyword">window</span> <span class="hljs-keyword">from</span> the right <span class="hljs-keyword">by</span> # (<span class="hljs-keyword">default</span> <span class="hljs-number">1</span>) C-w#&gt;    Increase/resize <span class="hljs-keyword">current</span> <span class="hljs-keyword">window</span> <span class="hljs-keyword">to</span> the right <span class="hljs-keyword">by</span> # (<span class="hljs-keyword">default</span> <span class="hljs-number">1</span>) </code></pre><h2 id="surround-vim"><a href="#surround-vim" class="headerlink" title="surround.vim"></a>surround.vim</h2><p>Surround.vim is all about “surroundings”: parentheses, brackets, quotes, XML tags, and more. The plugin provides mappings to easily delete, change and add such surroundings in pairs.</p><p>It’s easiest to explain with examples. Press <code>cs&quot;&#39;</code> inside</p><pre><code class="hljs 1c"><span class="hljs-string">&quot;Hello world!&quot;</span></code></pre><p>to change it to</p><pre><code class="hljs 1c">&#x27;Hello world!&#x27;</code></pre><p>Now press <code>cs&#39;</code> to change it to</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">q</span>&gt;</span>Hello world!<span class="hljs-tag">&lt;/<span class="hljs-name">q</span>&gt;</span></code></pre><p>To go full circle, press <code>cst&quot;</code> to get</p><pre><code class="hljs 1c"><span class="hljs-string">&quot;Hello world!&quot;</span></code></pre><p>To remove the delimiters entirely, press <code>ds&quot;</code>.</p><pre><code class="hljs erlang-repl">Hello world!</code></pre><p>Now with the cursor on “Hello”, press <code>ysiw]</code> (<code>iw</code> is a text object).</p><pre><code class="hljs csharp">[<span class="hljs-meta">Hello</span>] world!</code></pre><p>Let’s make that braces and add some space (use <code>&#125;</code> instead of <code>&#123;</code> for no space): <code>cs]&#123;</code></p><pre><code class="hljs dust"><span class="hljs-template-variable">&#123; Hello &#125;</span><span class="xml"> world!</span></code></pre><p>Now wrap the entire line in parentheses with <code>yssb</code> or <code>yss)</code>.</p><pre><code class="hljs clojure">(&#123; Hello &#125; world!)</code></pre><p>Revert to the original text: <code>ds&#123;ds)</code></p><pre><code class="hljs erlang-repl">Hello world!</code></pre><p>Emphasize hello: <code>ysiw</code></p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span> world!</code></pre><p>Finally, let’s try out visual mode. Press a capital V (for linewise visual mode) followed by <code>S</code>.</p><pre><code class="hljs angelscript">&lt;p <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">important</span>&quot;&gt;  &lt;<span class="hljs-symbol">em</span>&gt;<span class="hljs-symbol">Hello</span>&lt;/<span class="hljs-symbol">em</span>&gt; <span class="hljs-symbol">world</span>!&lt;/<span class="hljs-symbol">p</span>&gt;</code></pre><p>This plugin is very powerful for HTML and XML editing, a niche which currently seems underfilled in Vim land. (As opposed to HTML/XML <em>inserting</em>, for which many plugins are available). Adding, changing, and removing pairs of tags simultaneously is a breeze.</p><p>The <code>.</code> command will work with <code>ds</code>, <code>cs</code>, and <code>yss</code> if you install <a href="https://github.com/tpope/vim-repeat">repeat.vim</a>.</p><h2 id="Search-and-replace"><a href="#Search-and-replace" class="headerlink" title="Search and replace"></a>Search and replace</h2><h3 id="Basic-search-and-replace"><a href="#Basic-search-and-replace" class="headerlink" title="Basic search and replace"></a>Basic search and replace</h3><p>The <code>:substitute</code> command searches for a <a href="https://vim.fandom.com/wiki/VimTip188">text pattern</a>, and replaces it with a text string. There are many options, but these are what you probably want:</p><ul><li><p><code>:s/foo/bar/g</code></p><p>Find each occurrence of ‘foo’ (in the current line only), and replace it with ‘bar’.</p></li><li><p><code>:%s/foo/bar/g</code></p><p>Find each occurrence of ‘foo’ (in all lines), and replace it with ‘bar’.</p></li><li><p><code>:%s/foo/bar/gc</code></p><p>Change each ‘foo’ to ‘bar’, but ask for confirmation first.</p></li><li><p><code>:%s/\/bar/gc</code></p><p>Change only whole words exactly matching ‘foo’ to ‘bar’; ask for confirmation.</p></li><li><p><code>:%s/foo/bar/gci</code></p><p>Change each ‘foo’ (case insensitive due to the <code>i</code> flag) to ‘bar’; ask for confirmation.</p><p><code>:%s/foo\c/bar/gc</code> is the same because <code>\c</code> makes the search case insensitive.</p><p>This may be wanted after using <code>:set noignorecase</code> to make searches case sensitive (the default).</p></li><li><p><code>:%s/foo/bar/gcI</code></p><p>Change each ‘foo’ (case sensitive due to the <code>I</code> flag) to ‘bar’; ask for confirmation.</p><p><code>:%s/foo\C/bar/gc</code> is the same because <code>\C</code> makes the search case sensitive.</p><p>This may be wanted after using <code>:set ignorecase</code> to make searches case insensitive.</p></li></ul><p>The <code>g</code> flag means <em>global</em> – each occurrence in the line is changed, <strong>rather than just the first</strong>. This tip assumes the default setting for the <code>&#39;gdefault&#39;</code> and <code>&#39;edcompatible&#39;</code> option (off), which requires that the <code>g</code> flag be included in <code>%s///g</code> to perform a global substitute. Using <code>:set gdefault</code> creates confusion because then <code>%s///</code> is global, whereas <code>%s///g</code> is not (that is, <code>g</code> reverses its meaning).</p><p>When using the <code>c</code> flag, you need to confirm for each match what to do. Vim will output something like: <code>replace with foobar (y/n/a/q/l/^E/^Y)?</code> (where foobar is the replacement part of the <code>:s/.../.../</code> command. You can type <code>y</code> which means to substitute this match, <code>n</code> to skip this match, <code>a</code> to substitute this and all remaining matches (“all” remaining matches), <code>q</code> to quit the command, <code>l</code> to substitute this match and quit (think of “last”), <code>^E</code> to scroll the screen up by holding the Ctrl key and pressing E and <code>^Y</code> to scroll the screen down by holding the Ctrl key and pressing Y. However, the last two choices are only available, if your Vim is a normal, big or huge built or the insert_expand feature was enabled at compile time (look for <code>+insert_expand</code> in the output of <code>:version</code>).</p><p>Also when using the <code>c</code> flag, Vim will jump to the first match it finds starting from the top of the buffer and prompt you for confirmation to perform replacement on that match. Vim applies the <code>IncSearch</code> highlight group to the matched text to give you a visual cue as to which match it is operating on (set to <code>reverse</code> by default for all three term types as of Vim 7.3). Additionally, if more than one match is found and you have search highlighting enabled with <code>:set hlsearch</code>, Vim highlights the remaining matches with the <code>Search</code> highlight group. If you do use search highlighting, you should make sure that these two highlight groups are visually distinct or you won’t be able to easily tell which match Vim is prompting you to substitute.</p><h3 id="Details"><a href="#Details" class="headerlink" title="Details"></a>Details</h3><p><strong>Search range</strong>:</p><table><thead><tr><th><code>:s/foo/bar/g</code></th><th>Change each ‘foo’ to ‘bar’ in the current line.</th></tr></thead><tbody><tr><td><code>:%s/foo/bar/g</code></td><td>Change each ‘foo’ to ‘bar’ in all the lines.</td></tr><tr><td><code>:5,12s/foo/bar/g</code></td><td>Change each ‘foo’ to ‘bar’ for all lines from line 5 to line 12 (inclusive).</td></tr><tr><td><code>:&#39;a,&#39;bs/foo/bar/g</code></td><td>Change each ‘foo’ to ‘bar’ for all lines from mark a to mark b inclusive (see <strong>Note</strong> below).</td></tr><tr><td><code>:&#39;&lt;,&#39;&gt;s/foo/bar/g</code></td><td>When compiled with <code>+visual</code>, change each ‘foo’ to ‘bar’ for all lines within a visual selection. Vim automatically appends the visual selection range (‘&lt;,’&gt;) for any ex command when you select an area and enter <code>:</code>. Also, see <strong>Note</strong> below.</td></tr><tr><td><code>:.,$s/foo/bar/g</code></td><td>Change each ‘foo’ to ‘bar’ for all lines from the current line (.) to the last line ($) inclusive.</td></tr><tr><td><code>:.,+2s/foo/bar/g</code></td><td>Change each ‘foo’ to ‘bar’ for the current line (.) and the two next lines (+2).</td></tr><tr><td><code>:g/^baz/s/foo/bar/g</code></td><td>Change each ‘foo’ to ‘bar’ in each line starting with ‘baz’.</td></tr></tbody></table><p><strong>When searching</strong>:</p><p><strong>When replacing</strong>:</p><p>You can use <strong>other delimiters</strong> with substitute:</p><p>Save typing by using <code>\zs</code> and <code>\ze</code> to set the <strong>start and end of a pattern</strong>. For example, instead of:</p><p>Use:</p><p> :s/Copyright \zs2007\ze All Rights Reserved/2008/ </p><h2 id="Additional-examples"><a href="#Additional-examples" class="headerlink" title="Additional examples"></a>Additional examples</h2><ul><li><p><code>:%s/foo/bar/</code></p><p>On each line, replace the first occurrence of “foo” with “bar”.</p></li><li><p><code>:%s/.*\zsfoo/bar/</code></p><p>On each line, replace the last occurrence of “foo” with “bar”.</p></li><li><p><code>:%s/\//g</code></p><p>On each line, delete all occurrences of the whole word “foo”.</p></li><li><p><code>:%s/\.*//</code></p><p>On each line, delete the whole word “foo” and all following text (to end of line).</p></li><li><p><code>:%s/\.\&#123;5&#125;//</code></p><p>On each line, delete the first occurrence of the whole word “foo” and the following five characters.</p></li><li><p><code>:%s/\\zs.*//</code></p><p>On each line, delete all text following the whole word “foo” (to end of line).</p></li><li><p><code>:%s/.*\//</code></p><p>On each line, delete the whole word “foo” and all preceding text (from beginning of line).</p></li><li><p><code>:%s/.*\ze\//</code></p><p>On each line, delete all the text preceding the whole word “foo” (from beginning of line).</p></li><li><p><code>:%s/.*\(\\).*/\1/</code></p><p>On each line, delete all the text preceding and following the whole word “foo”.</p></li><li><p>`:%s/\</p><p>On each line, replace each occurrence of “foo” (which starts a word and is not followed by “bar”) by “toto”.</p></li><li><p><code>:s/^\(\w\)/\u\1/</code></p><p>If the first character at the beginning of the <em>current line only</em> is lowercase, switch it to uppercase using <code>\u</code> (see <a href="https://vim.fandom.com/wiki/Switching_case_of_characters">switching case of characters</a>).</p></li><li><p><code>:%s/\(.*\n\)\&#123;5\&#125;/&amp;\r/</code></p><p>Insert a blank line every 5 lines.</p><p>The pattern searches for <code>\(.*\n\)</code> (any line including its line ending) repeated five times (<code>\&#123;5\&#125;</code>).</p><p>The replacement is <code>&amp;</code> (the text that was found), followed by <code>\r</code> (newline).</p></li><li><p><code>:%s/\/\=len(add(list, submatch(1)))?submatch(0):submatch(0)/g</code></p><p>Get a list of search results. (the list must exist)</p><p>Sets the <code>modified</code> flag, because of the replacement, but the content is unchanged.</p><p><strong>Note</strong>: With a recent enough Vim (version 7.3.627 or higher), you can simplify this to:</p></li><li><p><code>:%s/\/\=add(list, submatch(1))/gn</code></p><p>This has the advantage, that the buffer won’t be marked modified and no extra undo state is created. The expression in the replacement part is executed in the sandbox and not allowed to modify the buffer.</p></li></ul><h2 id="Special-cases"><a href="#Special-cases" class="headerlink" title="Special cases"></a>Special cases</h2><p>For substituting patterns with corresponding case-sensitive text, Michael Geddes’s <a href="https://www.vim.org/scripts/script.php?script_id=6">keepcase</a> plugin can be used, e.g.:</p><ul><li><p><code>:%SubstituteCase/\cHello/goodBye/g</code></p><p>Substitute ‘Hello hello helLo HELLO’ by ‘Goodbye goodbye goodBye GOODBYE’</p></li></ul><p>For changing the offsets in a patch file (line number of a block), this little snippet can be used:</p><ul><li><code>s/^@@ -\(\d\+\),\(\d\+\) +\(\d\+\),\(\d\+\) @@$/\=&quot;@@ -&quot;.eval(submatch(1)+*offsetdiff*).&quot;,&quot;.submatch(2).&quot; +&quot;.eval(submatch(3)+*offsetdiff*).&quot;,&quot;.submatch(4).&quot; @@&quot;/g</code></li></ul><p>Useful when we want to strip some blocks from a patch, without patch having to complain about offset differences.</p>]]></content>
    
    
    <categories>
      
      <category>vim</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>trick</title>
    <link href="/2020/12/08/tricks/"/>
    <url>/2020/12/08/tricks/</url>
    
    <content type="html"><![CDATA[<h2 id="python时间处理库"><a href="#python时间处理库" class="headerlink" title="python时间处理库"></a>python时间处理库</h2><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> python-dateutil</code></pre><h2 id="在mongodb中插入日期类型"><a href="#在mongodb中插入日期类型" class="headerlink" title="在mongodb中插入日期类型"></a>在mongodb中插入日期类型</h2><pre><code class="hljs python"><span class="hljs-keyword">import</span> pymongo<span class="hljs-keyword">from</span> dateutil <span class="hljs-keyword">import</span> parserdateStr = <span class="hljs-string">&quot;2019-05-14 01:11:11&quot;</span>myDatetime = parser.parse(dateStr)client = pymongo.MongoClient(host=<span class="hljs-string">&quot;127.0.0.1&quot;</span>, port=<span class="hljs-number">27017</span>)db = client[<span class="hljs-string">&quot;test&quot;</span>]db.ceshi.insert(&#123;<span class="hljs-string">&quot;date&quot;</span>: myDatetime&#125;)client.close()</code></pre><h2 id="在mongodb中查询大于-小于某个时间点的数据"><a href="#在mongodb中查询大于-小于某个时间点的数据" class="headerlink" title="在mongodb中查询大于/小于某个时间点的数据"></a>在mongodb中查询大于/小于某个时间点的数据</h2><pre><code class="hljs apache"><span class="hljs-attribute">documents</span> = collection.find(&#123;<span class="hljs-string">&quot;date&quot;</span>: &#123;<span class="hljs-string">&quot;$lt&quot;</span>: datetime(<span class="hljs-number">2019</span>, <span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">15</span>,<span class="hljs-number">40</span>,<span class="hljs-number">3</span>)&#125;&#125;).sort(&#x27;date&#x27;)</code></pre><h2 id="python-打包pandas文件"><a href="#python-打包pandas文件" class="headerlink" title="python 打包pandas文件"></a>python 打包pandas文件</h2><ol><li><p>首先第一次进行打包，会在py目录下生成spec文件，是一个打包脚本</p></li><li><p>编辑其内容。添加隐藏的包</p><pre><code class="hljs python">hiddenimports=[ <span class="hljs-string">&#x27;pandas&#x27;</span>, <span class="hljs-string">&#x27;numpy&#x27;</span> ]</code></pre></li><li><p>如果遇到 recursion limit 错误, 在spec文件中添加如下两行</p></li></ol><pre><code class="hljs python"><span class="hljs-keyword">import</span> syssys.setrecursionlimit(<span class="hljs-number">2000000</span></code></pre><h2 id="Python-datetime-格式化"><a href="#Python-datetime-格式化" class="headerlink" title="Python datetime 格式化"></a>Python datetime 格式化</h2><pre><code class="hljs python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetimenow = datetime.now()now.strftime(<span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</code></pre>]]></content>
    
    
    <categories>
      
      <category>trick</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Command-line Environment</title>
    <link href="/2020/12/08/missing/Command-line%20Environment/"/>
    <url>/2020/12/08/missing/Command-line%20Environment/</url>
    
    <content type="html"><![CDATA[<h2 id="Pausing-and-backgrounding-processes"><a href="#Pausing-and-backgrounding-processes" class="headerlink" title="Pausing and backgrounding processes"></a>Pausing and backgrounding processes</h2><p>Signals can do other things beyond killing a process. For instance, <code>SIGSTOP</code> pauses a process. In the terminal, typing <code>Ctrl-Z</code> will prompt the shell to send a <code>SIGTSTP</code> signal, short for Terminal Stop (i.e. the terminal’s version of <code>SIGSTOP</code>).</p><p>We can then continue the paused job in the foreground or in the background using <a href="https://www.man7.org/linux/man-pages/man1/fg.1p.html"><code>fg</code></a> or <a href="http://man7.org/linux/man-pages/man1/bg.1p.html"><code>bg</code></a>, respectively.</p><pre><code class="hljs bash">$ sleep 1000^Z[1]  + 18653 suspended  sleep 1000$ nohup sleep 2000 &amp;[2] 18745appending output to nohup.out$ <span class="hljs-built_in">jobs</span>[1]  + suspended  sleep 1000[2]  - running    nohup sleep 2000$ <span class="hljs-built_in">bg</span> %1[1]  - 18653 continued  sleep 1000$ <span class="hljs-built_in">jobs</span>[1]  - running    sleep 1000[2]  + running    nohup sleep 2000$ <span class="hljs-built_in">kill</span> -STOP %1[1]  + 18653 suspended (signal)  sleep 1000$ <span class="hljs-built_in">jobs</span>[1]  + suspended (signal)  sleep 1000[2]  - running    nohup sleep 2000$ <span class="hljs-built_in">kill</span> -SIGHUP %1[1]  + 18653 hangup     sleep 1000$ <span class="hljs-built_in">jobs</span>[2]  + running    nohup sleep 2000$ <span class="hljs-built_in">kill</span> -SIGHUP %2$ <span class="hljs-built_in">jobs</span>[2]  + running    nohup sleep 2000$ <span class="hljs-built_in">kill</span> %2[2]  + 18745 terminated  nohup sleep 2000$ <span class="hljs-built_in">jobs</span></code></pre><h1 id="Terminal-Multiplexers-Tmux"><a href="#Terminal-Multiplexers-Tmux" class="headerlink" title="Terminal Multiplexers(Tmux)"></a>Terminal Multiplexers(Tmux)</h1><ul><li>Sessions</li></ul><p>  - a session is an independent workspace with one or more windows</p><ul><li><code>tmux</code> starts a new session.</li><li><code>tmux new -s NAME</code> starts it with that name.</li><li><code>tmux ls</code> lists the current sessions</li><li>Within <code>tmux</code> typing <code> d</code> detaches the current session</li><li><code>tmux a</code> attaches the last session. You can use <code>-t</code> flag to specify which</li></ul><ul><li>Windows</li></ul><p>  - Equivalent to tabs in editors or browsers, they are visually separate parts of the same session</p><ul><li><code> c</code> Creates a new window. To close it you can just terminate the shells doing ``</li><li><code> N</code> Go to the <em>N</em> th window. Note they are numbered</li><li><code> p</code> Goes to the previous window</li><li><code> n</code> Goes to the next window</li><li><code> ,</code> Rename the current window</li><li><code> w</code> List current windows</li></ul><ul><li>Panes</li></ul><p>  - Like vim splits, panes let you have multiple shells in the same visual display.</p><ul><li><code> &quot;</code> Split the current pane horizontally</li><li><code> %</code> Split the current pane vertically</li><li><code> 方向键</code> Move to the pane in the specified <em>direction</em>. Direction here means arrow keys.</li><li><code> z</code> Toggle zoom for the current pane</li><li><code> [</code> Start scrollback. You can then press <code>to start a selection and</code> to copy that selection.</li><li><code> x</code> kill pane </li></ul><ul><li>Tab<ul><li><code>c</code> create tab </li><li><code>n</code> 、<code>p</code>  、 <code>l</code>  switch </li><li><code>num</code>数字键在不同的tab中切换<h1 id="Aliases"><a href="#Aliases" class="headerlink" title="Aliases"></a>Aliases</h1></li></ul></li></ul><p>It can become tiresome typing long commands that involve many flags or verbose options. For this reason, most shells support <em>aliasing</em>. A shell alias is a short form for another command that your shell will replace automatically for you. For instance, an alias in bash has the following structure:</p><pre><code class="hljs bash"><span class="hljs-built_in">alias</span> alias_name=<span class="hljs-string">&quot;command_to_alias arg1 arg2&quot;</span></code></pre><p>Note that there is no space around the equal sign <code>=</code>, because <a href="https://www.man7.org/linux/man-pages/man1/alias.1p.html"><code>alias</code></a> is a shell command that takes a single argument.</p><p>Aliases have many convenient features:</p><pre><code class="hljs bash"><span class="hljs-comment"># Make shorthands for common flags</span><span class="hljs-built_in">alias</span> ll=<span class="hljs-string">&quot;ls -lh&quot;</span><span class="hljs-comment"># Save a lot of typing for common commands</span><span class="hljs-built_in">alias</span> gs=<span class="hljs-string">&quot;git status&quot;</span><span class="hljs-built_in">alias</span> gc=<span class="hljs-string">&quot;git commit&quot;</span><span class="hljs-built_in">alias</span> v=<span class="hljs-string">&quot;vim&quot;</span><span class="hljs-comment"># Save you from mistyping</span><span class="hljs-built_in">alias</span> sl=ls<span class="hljs-comment"># Overwrite existing commands for better defaults</span><span class="hljs-built_in">alias</span> mv=<span class="hljs-string">&quot;mv -i&quot;</span>           <span class="hljs-comment"># -i prompts before overwrite</span><span class="hljs-built_in">alias</span> mkdir=<span class="hljs-string">&quot;mkdir -p&quot;</span>     <span class="hljs-comment"># -p make parent dirs as needed</span><span class="hljs-built_in">alias</span> df=<span class="hljs-string">&quot;df -h&quot;</span>           <span class="hljs-comment"># -h prints human readable format</span><span class="hljs-comment"># Alias can be composed</span><span class="hljs-built_in">alias</span> la=<span class="hljs-string">&quot;ls -A&quot;</span><span class="hljs-built_in">alias</span> lla=<span class="hljs-string">&quot;la -l&quot;</span><span class="hljs-comment"># To ignore an alias run it prepended with \</span>\ls<span class="hljs-comment"># Or disable an alias altogether with unalias</span><span class="hljs-built_in">unalias</span> la<span class="hljs-comment"># To get an alias definition just call it with alias</span><span class="hljs-built_in">alias</span> ll<span class="hljs-comment"># Will print ll=&#x27;ls -lh&#x27;</span></code></pre><h1 id="Remote-Machines"><a href="#Remote-Machines" class="headerlink" title="Remote Machines"></a>Remote Machines</h1><p>It has become more and more common for programmers to use remote servers in their everyday work. If you need to use remote servers in order to deploy backend software or you need a server with higher computational capabilities, you will end up using a Secure Shell (SSH). As with most tools covered, SSH is highly configurable so it is worth learning about it.</p><p>To <code>ssh</code> into a server you execute a command as follows</p><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> foo<span class="hljs-variable">@bar</span>.mit.edu</code></pre><p>Here we are trying to ssh as user <code>foo</code> in server <code>bar.mit.edu</code>. The server can be specified with a URL (like <code>bar.mit.edu</code>) or an IP (something like <code>foobar@192.168.1.42</code>). Later we will see that if we modify ssh config file you can access just using something like <code>ssh bar</code>.</p><h2 id="Executing-commands"><a href="#Executing-commands" class="headerlink" title="Executing commands"></a>Executing commands</h2><p>An often overlooked feature of <code>ssh</code> is the ability to run commands directly. <code>ssh foobar@server ls</code> will execute <code>ls</code> in the home folder of foobar. It works with pipes, so <code>ssh foobar@server ls | grep PATTERN</code> will grep locally the remote output of <code>ls</code> and <code>ls | ssh foobar@server grep PATTERN</code> will grep remotely the local output of <code>ls</code>.</p><h2 id="SSH-Keys"><a href="#SSH-Keys" class="headerlink" title="SSH Keys"></a>SSH Keys</h2><p>Key-based authentication exploits public-key cryptography to prove to the server that the client owns the secret private key without revealing the key. This way you do not need to reenter your password every time. Nevertheless, the private key (often <code>~/.ssh/id_rsa</code> and more recently <code>~/.ssh/id_ed25519</code>) is effectively your password, so treat it like so.</p><h3 id="Key-generation"><a href="#Key-generation" class="headerlink" title="Key generation"></a>Key generation</h3><p>To generate a pair you can run <a href="https://www.man7.org/linux/man-pages/man1/ssh-keygen.1.html"><code>ssh-keygen</code></a>.</p><pre><code class="hljs apache"><span class="hljs-attribute">ssh</span>-keygen -o -a <span class="hljs-number">100</span> -t ed<span class="hljs-number">25519</span> -f ~/.ssh/id_ed<span class="hljs-number">25519</span></code></pre><p>You should choose a passphrase, to avoid someone who gets hold of your private key to access authorized servers. Use <a href="https://www.man7.org/linux/man-pages/man1/ssh-agent.1.html"><code>ssh-agent</code></a> or <a href="https://linux.die.net/man/1/gpg-agent"><code>gpg-agent</code></a> so you do not have to type your passphrase every time.</p><p>If you have ever configured pushing to GitHub using SSH keys, then you have probably done the steps outlined <a href="https://help.github.com/articles/connecting-to-github-with-ssh/">here</a> and have a valid key pair already. To check if you have a passphrase and validate it you can run <code>ssh-keygen -y -f /path/to/key</code>.</p><h3 id="Key-based-authentication"><a href="#Key-based-authentication" class="headerlink" title="Key based authentication"></a>Key based authentication</h3><p><code>ssh</code> will look into <code>.ssh/authorized_keys</code> to determine which clients it should let in. To copy a public key over you can use:</p><pre><code class="hljs nginx"><span class="hljs-attribute">cat</span> .ssh/id_ed25519.pub | ssh foobar<span class="hljs-variable">@remote</span> <span class="hljs-string">&#x27;cat &gt;&gt; ~/.ssh/authorized_keys&#x27;</span></code></pre><p>A simpler solution can be achieved with <code>ssh-copy-id</code> where available:</p><pre><code class="hljs applescript">ssh-<span class="hljs-keyword">copy</span>-<span class="hljs-built_in">id</span> -i .ssh/id_ed25519.pub foobar@remote</code></pre><h2 id="Copying-files-over-SSH"><a href="#Copying-files-over-SSH" class="headerlink" title="Copying files over SSH"></a>Copying files over SSH</h2><p>There are many ways to copy files over ssh:</p><ul><li><code>ssh+tee</code>, the simplest is to use <code>ssh</code> command execution and STDIN input by doing <code>cat localfile | ssh remote_server tee serverfile</code>. Recall that <a href="https://www.man7.org/linux/man-pages/man1/tee.1.html"><code>tee</code></a> writes the output from STDIN into a file.</li><li><a href="https://www.man7.org/linux/man-pages/man1/scp.1.html"><code>scp</code></a> when copying large amounts of files/directories, the secure copy <code>scp</code> command is more convenient since it can easily recurse over paths. The syntax is <code>scp path/to/local_file remote_host:path/to/remote_file</code></li><li><a href="https://www.man7.org/linux/man-pages/man1/rsync.1.html"><code>rsync</code></a> improves upon <code>scp</code> by detecting identical files in local and remote, and preventing copying them again. It also provides more fine grained control over symlinks, permissions and has extra features like the <code>--partial</code> flag that can resume from a previously interrupted copy. <code>rsync</code> has a similar syntax to <code>scp</code>.</li></ul><h2 id="SSH-Configuration"><a href="#SSH-Configuration" class="headerlink" title="SSH Configuration"></a>SSH Configuration</h2><p>We have covered many many arguments that we can pass. A tempting alternative is to create shell aliases that look like</p><pre><code class="hljs monkey"><span class="hljs-keyword">alias</span> <span class="hljs-title">my_server</span>=<span class="hljs-string">&quot;ssh -i ~/.id_ed25519 --port 2222 -L 9999:localhost:8888 foobar@remote_server</span></code></pre><p>However, there is a better alternative using <code>~/.ssh/config</code>.</p><pre><code class="hljs routeros">Host vm   <span class="hljs-built_in"> User </span>foobar    HostName 172.16.174.141   <span class="hljs-built_in"> Port </span>2222    IdentityFile ~/.ssh/id_ed25519    LocalForward 9999 localhost:8888<span class="hljs-comment"># Configs can also take wildcards</span>Host *.mit.edu   <span class="hljs-built_in"> User </span>foobaz</code></pre><p>An additional advantage of using the <code>~/.ssh/config</code> file over aliases is that other programs like <code>scp</code>, <code>rsync</code>, <code>mosh</code>, &amp;c are able to read it as well and convert the settings into the corresponding flags.</p><p>Note that the <code>~/.ssh/config</code> file can be considered a dotfile, and in general it is fine for it to be included with the rest of your dotfiles. However, if you make it public, think about the information that you are potentially providing strangers on the internet: addresses of your servers, users, open ports, &amp;c. This may facilitate some types of attacks so be thoughtful about sharing your SSH configuration.</p><p>Server side configuration is usually specified in <code>/etc/ssh/sshd_config</code>. Here you can make changes like disabling password authentication, changing ssh ports, enabling X11 forwarding, &amp;c. You can specify config settings on a per user basis.</p>]]></content>
    
    
    <categories>
      
      <category>missing</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Shell Tools and Scripting</title>
    <link href="/2020/12/08/missing/Shell%20Scripting/"/>
    <url>/2020/12/08/missing/Shell%20Scripting/</url>
    
    <content type="html"><![CDATA[<h2 id="shell-脚本"><a href="#shell-脚本" class="headerlink" title="shell 脚本"></a>shell 脚本</h2><h2 id="在程序间创建连接"><a href="#在程序间创建连接" class="headerlink" title="在程序间创建连接"></a>在程序间创建连接</h2><p>信息的流动称为<strong>流</strong>，程序中存在两个流。</p><p>流入程序的称为<strong>输入流</strong>，流出的则称为<strong>输出流</strong>。</p><p>程序读取信息时会从输入流中进行读取，相反打印信息时则是输出到输出流中。</p><p>例如重定向 &gt; 可以将程序的输入流和输出流分别重定向到文件中。</p><blockquote><p>最简单的重定向是 &lt; file 和 &gt; file。这两个命令可以将程序的输入输出流分别重定向到文件：</p></blockquote><pre><code class="hljs sh">$ <span class="hljs-built_in">echo</span> hello &gt; hello.txt$ cat hello.txthello$ cat &lt; hello.txt &gt; hello2.txt$ cat hello2.txthello</code></pre><p>&gt;&gt; 表示追加内容(append)。</p><pre><code class="hljs sh">$ cat hello.txthello$ <span class="hljs-built_in">echo</span> hello &gt;&gt; hello.txt$ cat hello.txthellohello</code></pre><p>&gt; 使用管道（ pipes ），我们能够更好的利用文件重定向。 |操作符允许我们将一个程序的输出和另外一个程序的输入连接起来。</p><p>管道线的用法实例。 </p><pre><code class="hljs sh">missing:~$ ls -l / | tail -n1drwxr-xr-x 1 root  root  4096 Jun 20  2019 varmissing:~$ curl --head --silent google.com | grep --ignore-case content-length | cut --delimiter=<span class="hljs-string">&#x27; &#x27;</span> -f2219</code></pre><h3 id="不要有空格"><a href="#不要有空格" class="headerlink" title="不要有空格"></a>不要有空格</h3><p>To assign variables in bash, use the syntax <code>foo=bar</code> and access the value of the variable with <code>$foo</code>. <strong>Note that <code>foo = bar</code> will not work</strong> since it is interpreted as calling the <code>foo</code> program with arguments <code>=</code> and <code>bar</code>. In general, in shell scripts the space character will perform argument splitting. This behavior can be confusing to use at first, so always check for that.</p><h3 id="单引号和双引号"><a href="#单引号和双引号" class="headerlink" title="单引号和双引号"></a>单引号和双引号</h3><p>单引号内部的内容会原样输出。双引号则会进行相应的替换:</p><p>Strings in bash can be defined with <code>&#39;</code> and <code>&quot;</code> delimiters, but they are not equivalent. Strings delimited with <code>&#39;</code> are literal strings and will not substitute variable values whereas <code>&quot;</code> delimited strings will. </p><pre><code class="hljs bash">foo=bar<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$foo</span>&quot;</span><span class="hljs-comment"># prints bar</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;$foo&#x27;</span><span class="hljs-comment"># prints $foo</span></code></pre><h2 id="号"><a href="#号" class="headerlink" title="$号"></a>$号</h2><ul><li><code>$0</code> - Name of the script</li><li><code>$1</code> to <code>$9</code> - Arguments to the script. <code>$1</code> is the first argument and so on.</li><li><code>$@</code> - All the arguments</li><li><code>$#</code> - Number of arguments</li><li><code>$?</code> - Return code of the previous command</li><li><code>$$</code> - Process identification number (PID) for the current script</li><li><code>!!</code> - Entire last command, including arguments. A common pattern is to execute a command only for it to fail due to missing permissions; you can quickly re-execute the command with sudo by doing <code>sudo !!</code></li><li><code>$_</code> - Last argument from the last command. If you are in an interactive shell, you can also quickly get this value by typing <code>Esc</code> followed by <code>.</code></li></ul><h2 id="short-circuiting-operators-逻辑短路符号"><a href="#short-circuiting-operators-逻辑短路符号" class="headerlink" title="short-circuiting operators 逻辑短路符号"></a>short-circuiting operators 逻辑短路符号</h2><pre><code class="hljs shell">false || echo &quot;Oops, fail&quot;<span class="hljs-meta">#</span><span class="bash"> Oops, fail</span>true || echo &quot;Will not be printed&quot;<span class="hljs-meta">#</span>true &amp;&amp; echo &quot;Things went well&quot;<span class="hljs-meta">#</span><span class="bash"> Things went well</span>false &amp;&amp; echo &quot;Will not be printed&quot;<span class="hljs-meta">#</span>true ; echo &quot;This will always run&quot;<span class="hljs-meta">#</span><span class="bash"> This will always run</span>false ; echo &quot;This will always run&quot;<span class="hljs-meta">#</span><span class="bash"> This will always run</span></code></pre><h2 id="大括号"><a href="#大括号" class="headerlink" title="{} 大括号"></a>{} 大括号</h2><pre><code class="hljs bash">convert image.&#123;png,jpg&#125;<span class="hljs-comment"># Will expand to</span>convert image.png image.jpgcp /path/to/project/&#123;foo,bar,baz&#125;.sh /newpath<span class="hljs-comment"># Will expand to</span>cp /path/to/project/foo.sh /path/to/project/bar.sh /path/to/project/baz.sh /newpath<span class="hljs-comment"># Globbing techniques can also be combined</span>mv *&#123;.py,.sh&#125; folder<span class="hljs-comment"># Will move all *.py and *.sh files</span>mkdir foo bar<span class="hljs-comment"># This creates files foo/a, foo/b, ... foo/h, bar/a, bar/b, ... bar/h</span>touch &#123;foo,bar&#125;/&#123;a..h&#125;touch foo/x bar/y<span class="hljs-comment"># Show differences between files in foo and bar</span>diff &lt;(ls foo) &lt;(ls bar)<span class="hljs-comment"># Outputs</span><span class="hljs-comment"># &lt; x</span><span class="hljs-comment"># ---</span><span class="hljs-comment"># &gt; y</span></code></pre><h2 id="find：查找文件命令"><a href="#find：查找文件命令" class="headerlink" title="find：查找文件命令"></a>find：查找文件命令</h2><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> Find all directories named src</span>find . -name src -type d<span class="hljs-meta">#</span><span class="bash"> Find all python files that have a folder named <span class="hljs-built_in">test</span> <span class="hljs-keyword">in</span> their path</span>find . -path &#x27;*/test/*.py&#x27; -type f<span class="hljs-meta">#</span><span class="bash"> Find all files modified <span class="hljs-keyword">in</span> the last day</span>find . -mtime -1<span class="hljs-meta">#</span><span class="bash"> Find all zip files with size <span class="hljs-keyword">in</span> range 500k to 10M</span>find . -size +500k -size -10M -name &#x27;*.tar.gz&#x27;</code></pre><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> Delete all files with .tmp extension</span>find . -name &#x27;*.tmp&#x27; -exec rm &#123;&#125; \;<span class="hljs-meta">#</span><span class="bash"> Find all PNG files and convert them to JPG</span>find . -name &#x27;*.png&#x27; -exec convert &#123;&#125; &#123;&#125;.jpg \;</code></pre><h2 id="查找代码"><a href="#查找代码" class="headerlink" title="查找代码"></a>查找代码</h2><p>grep<br>  -C: 获取查找结果的上下文。(Context)<br>  -v：对结果进行反选，即输出不匹配的结果。 (Invert)<br>  -C 5 ： 输出匹配结果的前后 5 行 。<br>  -R： 递归进入子目录并搜索所有文本文件。</p><pre><code class="hljs bash"><span class="hljs-comment"># 查找所有使用了 requests 库的文件</span>rg -t py <span class="hljs-string">&#x27;import requests&#x27;</span><span class="hljs-comment"># 查找所有没有写 shebang 的文件（包含隐藏文件）</span>rg -u --files-without-match <span class="hljs-string">&quot;^#!&quot;</span><span class="hljs-comment"># 查找所有的foo字符串，并打印其之后的5行</span>rg foo -A 5<span class="hljs-comment"># 打印匹配的统计信息（匹配的行和文件的数量）</span>rg --stats PATTERN</code></pre><h2 id="文件夹导航"><a href="#文件夹导航" class="headerlink" title="文件夹导航"></a>文件夹导航</h2><p>nnn命令和ranger命令</p>]]></content>
    
    
    <categories>
      
      <category>missing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sdfds</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2020/12/08/missing/Git/"/>
    <url>/2020/12/08/missing/Git/</url>
    
    <content type="html"><![CDATA[<h2 id="snapshot-快照"><a href="#snapshot-快照" class="headerlink" title="snapshot 快照"></a>snapshot 快照</h2><p>Git models the history of a collection of files and folders within some top-level directory as a series of snapshots. In Git terminology, a file is called a “<strong>blob</strong>”, and it’s just a bunch of bytes. A directory is called a “<strong>tree</strong>”, and it maps names to blobs or trees (so directories can contain other directories). A snapshot is the top-level tree that is being tracked. For example, we might have a tree as follows:</p><pre><code class="hljs gherkin"><span class="hljs-variable">&lt;root&gt;</span> (tree)|<span class="hljs-string">+- foo (tree)</span>|<span class="hljs-string">  </span>||<span class="hljs-string">  + bar.txt (blob, contents = &quot;hello world&quot;)</span>|+- baz.txt (blob, contents = <span class="hljs-string">&quot;git is wonderful&quot;</span>)</code></pre><h2 id="Modeling-history-relating-snapshots"><a href="#Modeling-history-relating-snapshots" class="headerlink" title="Modeling history: relating snapshots"></a>Modeling history: relating snapshots</h2><p>In Git, a history is a directed acyclic graph (DAG) of snapshots. That may sound like a fancy math word, but don’t be intimidated. All this means is that each snapshot in Git refers to a set of “parents”, the snapshots that preceded it. It’s a set of parents rather than a single parent (as would be the case in a linear history) because a snapshot might descend from multiple parents, for example due to combining (merging) two parallel branches of development.</p><h3 id="commit-history"><a href="#commit-history" class="headerlink" title="commit history"></a>commit history</h3><p>Git calls these snapshots “commit”s. Visualizing a commit history** might look something like this:</p><pre><code class="hljs brainfuck"><span class="hljs-comment">o</span> &lt;-- <span class="hljs-comment">o</span> &lt;-- <span class="hljs-comment">o</span> &lt;-- <span class="hljs-comment">o</span><span class="hljs-comment"></span>            <span class="hljs-comment">^</span><span class="hljs-comment"></span>             <span class="hljs-comment">\</span><span class="hljs-comment"></span>              --<span class="hljs-literal">-</span> <span class="hljs-comment">o</span> &lt;-- <span class="hljs-comment">o</span></code></pre><h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><p> In the future, these branches may be merged to create a new snapshot that incorporates both of the features, producing a new history that looks like this, with the newly created merge commit shown in bold:</p><pre><code class="hljs brainfuck"><span class="hljs-comment">o</span> &lt;-- <span class="hljs-comment">o</span> &lt;-- <span class="hljs-comment">o</span> &lt;-- <span class="hljs-comment">o</span> &lt;--<span class="hljs-literal">-</span><span class="hljs-literal">-</span> <span class="hljs-comment">o</span><span class="hljs-comment"></span>            <span class="hljs-comment">^</span>            <span class="hljs-comment">/</span><span class="hljs-comment"></span>             <span class="hljs-comment">\</span>          <span class="hljs-comment">v</span><span class="hljs-comment"></span>              --<span class="hljs-literal">-</span> <span class="hljs-comment">o</span> &lt;-- <span class="hljs-comment">o</span></code></pre><p>Commits in Git are <strong>immutable(不可变的)</strong>. This doesn’t mean that mistakes can’t be corrected, however; it’s just that “edits” to the commit history are actually creating entirely new commits, and references (see below) are updated to point to the new ones.</p><h2 id="Data-model-as-pseudocode-（数据模型的伪代码）"><a href="#Data-model-as-pseudocode-（数据模型的伪代码）" class="headerlink" title="Data model, as pseudocode （数据模型的伪代码）"></a>Data model, as pseudocode （数据模型的伪代码）</h2><p>It may be instructive to see Git’s data model written down in pseudocode:</p><pre><code class="hljs lasso"><span class="hljs-comment">// a file is a bunch of bytes</span><span class="hljs-keyword">type</span> blob = <span class="hljs-built_in">array</span>&lt;byte&gt;<span class="hljs-comment">// a directory contains named files and directories</span><span class="hljs-keyword">type</span> tree = <span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, tree | blob&gt;<span class="hljs-comment">// a commit has parents, metadata, and the top-level tree</span><span class="hljs-keyword">type</span> commit = struct &#123;    <span class="hljs-keyword">parent</span>: <span class="hljs-built_in">array</span>&lt;commit&gt;    author: <span class="hljs-built_in">string</span>    message: <span class="hljs-built_in">string</span>    snapshot: tree&#125;</code></pre><h2 id="Objects-and-content-addressing"><a href="#Objects-and-content-addressing" class="headerlink" title="Objects and content-addressing"></a>Objects and content-addressing</h2><p>An “object” is a blob, tree, or commit:</p><pre><code class="hljs pgsql"><span class="hljs-keyword">type</span> <span class="hljs-keyword">object</span> = blob | tree | <span class="hljs-keyword">commit</span></code></pre><p>In Git data store, all objects are content-addressed by their <strong><a href="https://en.wikipedia.org/wiki/SHA-1">SHA-1 hash</a></strong>.</p><pre><code class="hljs scala">objects = map&lt;string, <span class="hljs-class"><span class="hljs-keyword">object</span><span class="hljs-title">&gt;</span></span><span class="hljs-class"></span><span class="hljs-class"><span class="hljs-title">def</span> <span class="hljs-title">store</span>(<span class="hljs-params">object</span>)</span>:    id = sha1(<span class="hljs-class"><span class="hljs-keyword">object</span>)</span><span class="hljs-class">    <span class="hljs-title">objects</span>[id] </span>= <span class="hljs-class"><span class="hljs-keyword">object</span></span><span class="hljs-class"></span><span class="hljs-class"><span class="hljs-title">def</span> <span class="hljs-title">load</span>(<span class="hljs-params">id</span>)</span>:    <span class="hljs-keyword">return</span> objects[id]</code></pre><p> Blobs, trees, and commits are unified in this way: they are all objects. <strong>When they reference other objects, they don’t actually <em>contain</em> them in their on-disk representation, but have a reference to them by their hash.</strong> </p><p>For example, the tree for the example directory structure <a href="https://missing.csail.mit.edu/2020/version-control/#snapshots">above</a> (visualized using <code>git cat-file -p 698281bc680d1995c5f4caaf3359721a5a58d48d</code>), looks like this:</p><pre><code class="hljs apache"><span class="hljs-attribute">100644</span> blob <span class="hljs-number">4448</span>adbf<span class="hljs-number">7</span>ecd<span class="hljs-number">394</span>f<span class="hljs-number">42</span>ae<span class="hljs-number">135</span>bbeed<span class="hljs-number">9676</span>e<span class="hljs-number">894</span>af<span class="hljs-number">85</span>    baz.txt<span class="hljs-attribute">040000</span> tree c<span class="hljs-number">68</span>d<span class="hljs-number">233</span>a<span class="hljs-number">33</span>c<span class="hljs-number">5</span>c<span class="hljs-number">06</span>e<span class="hljs-number">0340</span>e<span class="hljs-number">4</span>c<span class="hljs-number">224</span>f<span class="hljs-number">0</span>afca<span class="hljs-number">87</span>c<span class="hljs-number">8</span>ce<span class="hljs-number">87</span>    foo</code></pre><p>The tree itself contains pointers to its contents, <code>baz.txt</code> (a blob) and <code>foo</code> (a tree). If we look at the contents addressed by the hash corresponding to baz.txt with <code>git cat-file -p 4448adbf7ecd394f42ae135bbeed9676e894af85</code>, we get the following:</p><pre><code class="hljs actionscript">git <span class="hljs-keyword">is</span> wonderful</code></pre><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>References其实就是字典, 因为object的SHA-1hash码太长,于是做了个字典, 比如”head” “master”就是一个reference, reference是可以变的</p><p>Now, all snapshots can be identified by their SHA-1 hash. That’s inconvenient, because humans aren’t good at remembering strings of 40 hexadecimal characters.</p><p>Git’s solution to this problem is human-readable names for SHA-1 hashes, called “references”. References are pointers to commits. Unlike objects, which are immutable, references are mutable (can be updated to point to a new commit). For example, the <code>master</code> reference usually points to the latest commit in the main branch of development.</p><pre><code class="hljs python">references = map&lt;string, string&gt;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update_reference</span>(<span class="hljs-params">name, id</span>):</span>    references[name] = id<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_reference</span>(<span class="hljs-params">name</span>):</span>    <span class="hljs-keyword">return</span> references[name]<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_reference</span>(<span class="hljs-params">name_or_id</span>):</span>    <span class="hljs-keyword">if</span> name_or_id <span class="hljs-keyword">in</span> references:        <span class="hljs-keyword">return</span> load(references[name_or_id])    <span class="hljs-keyword">else</span>:        <span class="hljs-keyword">return</span> load(name_or_id)</code></pre><p>With this, Git can use human-readable names like “master” to refer to a particular snapshot in the history, instead of a long hexadecimal string.</p><p>One detail is that we often want a notion of “where we currently are” in the history, so that when we take a new snapshot, we know what it is relative to (how we set the <code>parents</code> field of the commit). In Git, that “where we currently are” is a special reference called “HEAD”.</p><h2 id="Repositories"><a href="#Repositories" class="headerlink" title="Repositories"></a>Repositories</h2><p>Finally, we can define what (roughly) is a Git <em>repository</em>: it is the data <code>objects</code> and <code>references</code>.</p><p>On disk, all Git stores are objects and references: that’s all there is to Git’s data model. All <code>git</code> commands map to some manipulation of the commit DAG by adding objects and adding/updating references.</p><p>Whenever you’re typing in any command, think about what manipulation the command is making to the underlying graph data structure. Conversely, if you’re trying to make a particular kind of change to the commit DAG, e.g. “discard uncommitted changes and make the ‘master’ ref point to commit <code>5d83f9e</code>”, there’s probably a command to do it (e.g. in this case, <code>git checkout master; git reset --hard 5d83f9e</code>).</p><h1 id="Staging-area"><a href="#Staging-area" class="headerlink" title="Staging area"></a>Staging area</h1><p>This is another concept that’s orthogonal to the data model, but it’s a part of the interface to create commits.</p><p>One way you might imagine implementing snapshotting as described above is to have a “create snapshot” command that creates a new snapshot based on the <em>current state</em> of the working directory. Some version control tools work like this, but not Git. We want clean snapshots, and it might not always be ideal to make a snapshot from the current state. For example, imagine a scenario where you’ve implemented two separate features, and you want to create two separate commits, where the first introduces the first feature, and the next introduces the second feature. Or imagine a scenario where you have debugging print statements added all over your code, along with a bugfix; you want to commit the bugfix while discarding all the print statements.</p><p>Git accommodates such scenarios by allowing you to specify which modifications should be included in the next snapshot through a mechanism called the “staging area”.</p><h1 id="Git-command-line-interface"><a href="#Git-command-line-interface" class="headerlink" title="Git command-line interface"></a>Git command-line interface</h1><p>  <a href="https://git-scm.com/book/en/v2">Pro Git</a>  这里有更多</p><h3 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h3><ul><li><p><code>git help </code>: get help for a git command</p></li><li><p><code>git init</code>: creates a new git repo, with data stored in the <code>.git</code> directory</p></li><li><p><code>git status</code>: tells you what’s going on</p></li><li><p><code>git add </code>: adds files to staging area</p></li><li><pre><code class="plaintext">git commit&lt;!--hexoPostRenderEscape:&lt;pre&gt;&lt;code class=&quot;hljs markdown&quot;&gt;: creates a new commit</code></pre></li></ul><p><span class="hljs-bullet">  -</span> Write [<span class="hljs-string">good commit messages</span>](<span class="hljs-link"><a href="https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html">https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html</a></span>)!<br><span class="hljs-bullet">  -</span> Even more reasons to write [<span class="hljs-string">good commit messages</span>](<span class="hljs-link"><a href="https://chris.beams.io/posts/git-commit/">https://chris.beams.io/posts/git-commit/</a></span>)!</p><p><span class="hljs-bullet">-</span> <span class="hljs-code"><code>git log</code></span>: shows a flattened log of history</p><p><span class="hljs-bullet">-</span> <span class="hljs-code"><code>git log --all --graph --decorate</code></span>: visualizes history as a DAG</p><p><span class="hljs-bullet">-</span> <span class="hljs-code"><code>git diff </code></span>: show changes you made relative to the staging area</p><p><span class="hljs-bullet">-</span> <span class="hljs-code"><code>git diff  </code></span>: shows differences in a file between snapshots</p><p><span class="hljs-bullet">-</span> <span class="hljs-code"><code>git checkout </code></span>: updates HEAD and current branch</p><p><span class="hljs-section">### Branching and merging</span></p><p><span class="hljs-bullet">-</span> <span class="hljs-code"><code>git branch</code></span>: shows branches</p><p><span class="hljs-bullet">-</span> <span class="hljs-code"><code>git branch </code></span>: creates a branch</p><p><span class="hljs-bullet">-</span> <span class="hljs-code">```plaintext</span><br><span class="hljs-code">  git checkout -b &lt;name&gt;</span></code></pre>:hexoPostRenderEscape–&gt;</p><p>  : creates a branch and switches to it</p><ul><li>same as <code>git branch ; git checkout </code></li></ul><ul><li><p><code>git merge </code>: merges into current branch</p></li><li><p><code>git mergetool</code>: use a fancy tool to help resolve merge conflicts</p></li><li><p><code>git rebase</code>: rebase set of patches onto a new base</p></li></ul><h3 id="Remotes"><a href="#Remotes" class="headerlink" title="Remotes"></a>Remotes</h3><ul><li><code>git remote</code>: list remotes</li><li><code>git remote add  </code>: add a remote</li><li><code>git push  :</code>: send objects to remote, and update remote reference</li><li><code>git branch --set-upstream-to=/</code>: set up correspondence between local and remote branch</li><li><code>git fetch</code>: retrieve objects/references from a remote</li><li><code>git pull</code>: same as <code>git fetch; git merge</code></li><li><code>git clone</code>: download repository from remote</li></ul><h3 id="Undo"><a href="#Undo" class="headerlink" title="Undo"></a>Undo</h3><ul><li><code>git commit --amend</code>: edit a commit’s contents/message</li><li><code>git reset HEAD </code>: unstage a file</li><li><code>git checkout -- </code>: discard changes</li></ul><h3 id="Advanced-Git"><a href="#Advanced-Git" class="headerlink" title="Advanced Git"></a>Advanced Git</h3><ul><li><code>git config</code>: Git is <a href="https://git-scm.com/docs/git-config">highly customizable</a></li><li><code>git clone --depth=1</code>: shallow clone, without entire version history</li><li><code>git add -p</code>: interactive staging</li><li><code>git rebase -i</code>: interactive rebasing</li><li><code>git blame</code>: show who last edited which line</li><li><code>git stash</code>: temporarily remove modifications to working directory</li><li><code>git bisect</code>: binary search history (e.g. for regressions)</li><li><code>.gitignore</code>: <a href="https://git-scm.com/docs/gitignore">specify</a> intentionally untracked files to ignore</li></ul><h1 id="Miscellaneous-其他"><a href="#Miscellaneous-其他" class="headerlink" title="Miscellaneous(其他)"></a>Miscellaneous(其他)</h1><ul><li><strong>GUIs</strong>: there are many <a href="https://git-scm.com/downloads/guis">GUI clients</a> out there for Git. We personally don’t use them and use the command-line interface instead.</li><li><strong>Shell integration</strong>: it’s super handy to have a Git status as part of your shell prompt (<a href="https://github.com/olivierverdier/zsh-git-prompt">zsh</a>, <a href="https://github.com/magicmonty/bash-git-prompt">bash</a>). Often included in frameworks like <a href="https://github.com/ohmyzsh/ohmyzsh">Oh My Zsh</a>.</li><li><strong>Editor integration</strong>: similarly to the above, handy integrations with many features. <a href="https://github.com/tpope/vim-fugitive">fugitive.vim</a> is the standard one for Vim.</li><li><strong>Workflows</strong>: we taught you the data model, plus some basic commands; we didn’t tell you what practices to follow when working on big projects (and there are <a href="https://nvie.com/posts/a-successful-git-branching-model/">many</a> <a href="https://www.endoflineblog.com/gitflow-considered-harmful">different</a> <a href="https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow">approaches</a>).</li><li><strong>GitHub</strong>: Git is not GitHub. GitHub has a specific way of contributing code to other projects, called <a href="https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/about-pull-requests">pull requests</a>.</li><li><strong>Other Git providers</strong>: GitHub is not special: there are many Git repository hosts, like <a href="https://about.gitlab.com/">GitLab</a> and <a href="https://bitbucket.org/">BitBucket</a>.</li></ul><h1 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h1><ul><li><a href="https://git-scm.com/book/en/v2">Pro Git</a> is <strong>highly recommended reading</strong>. Going through Chapters 1–5 should teach you most of what you need to use Git proficiently, now that you understand the data model. The later chapters have some interesting, advanced material.</li><li><a href="https://ohshitgit.com/">Oh Shit, Git!?!</a> is a short guide on how to recover from some common Git mistakes.</li><li><a href="https://eagain.net/articles/git-for-computer-scientists/">Git for Computer Scientists</a> is a short explanation of Git’s data model, with less pseudocode and more fancy diagrams than these lecture notes.</li><li><a href="https://jwiegley.github.io/git-from-the-bottom-up/">Git from the Bottom Up</a> is a detailed explanation of Git’s implementation details beyond just the data model, for the curious.</li><li><a href="https://smusamashah.github.io/blog/2017/10/14/explain-git-in-simple-words">How to explain git in simple words</a></li><li><a href="https://learngitbranching.js.org/">Learn Git Branching</a> is a browser-based game that teaches you Git.</li></ul>]]></content>
    
    
    <categories>
      
      <category>missing</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Shell</title>
    <link href="/2020/12/08/missing/Shell/"/>
    <url>/2020/12/08/missing/Shell/</url>
    
    <content type="html"><![CDATA[<h2 id="在程序间创建连接"><a href="#在程序间创建连接" class="headerlink" title="在程序间创建连接"></a>在程序间创建连接</h2><p>信息的流动称为<strong>流</strong>，程序中存在两个流。</p><p>流入程序的称为<strong>输入流</strong>，流出的则称为<strong>输出流</strong>。</p><p>程序读取信息时会从输入流中进行读取，相反打印信息时则是输出到输出流中。</p><p>例如重定向 &gt; 可以将程序的输入流和输出流分别重定向到文件中。</p><blockquote><p>最简单的重定向是 &lt; file 和 &gt; file。这两个命令可以将程序的输入输出流分别重定向到文件：</p></blockquote><pre><code class="hljs sh">$ <span class="hljs-built_in">echo</span> hello &gt; hello.txt$ cat hello.txthello$ cat &lt; hello.txt &gt; hello2.txt$ cat hello2.txthello</code></pre><p>&gt;&gt; 表示追加内容(append)。</p><pre><code class="hljs sh">$ cat hello.txthello$ <span class="hljs-built_in">echo</span> hello &gt;&gt; hello.txt$ cat hello.txthellohello</code></pre><blockquote><p>使用管道（ pipes ），我们能够更好的利用文件重定向。 |操作符允许我们将一个程序的输出和另外一个程序的输入连接起来。</p></blockquote><p>管道线的用法实例。 </p>]]></content>
    
    
    <categories>
      
      <category>missing</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
